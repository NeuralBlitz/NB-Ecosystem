<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="null"><head><meta charset="utf-8"><meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=1"><title>Dhh</title><style>html {font: 14px "Times New Roman", serif;}body {background-color: transparent;padding: 1em 1.5rem;}a, a:visited {color: #00acc1;}h1, h2, h3, h4, h5, h6 {font-weight: normal;page-break-before: left;text-align: center;}header, nav {margin-bottom: 10rem;}header img {display: block;height: auto;margin: 0 auto;width: 100%;}header h1 {font-size: 3rem;line-height: 3rem;margin-top: 3rem;}header h3 {font-size: 1.5rem;line-height: 1.5rem;margin-top: 1rem;}nav h2 {font-size: 1.5rem;line-height: 1.5rem;margin-top: 1.5rem;}nav ol {list-style-type: none;padding-left: 1rem;}nav li {font-size: 1.2rem;line-height: 1.4rem;}section h2 {font-size: 2rem;line-height: 2rem;margin-top: 5rem;}section p {font-size: 1.2rem;line-height: 1.5rem;margin: 0 0 0.2rem 0;}article p:not(:first-of-type) {text-indent: 1.5rem;}section p:empty:before {content: " ";white-space: pre;}#top {background: rgba(0, 0, 0, 0.2);border-radius: 35px;bottom: 20px;display: none;height: 50px;position: fixed;text-decoration: none;transition: all 0.3s ease;right: 20px;width: 50px;}#top i {color: #fff;font-size: 19px;left: 16px;margin: 0;position: relative;top: 13px;transition: all 0.3s ease;}</style></head><body style="zoom: 1.0"><header><h1>Dhh</h1></header><nav><h2>Table of contents</h2><ol><li><a href="#s0">Sh</a></li></ol></nav><section><h2 id="s0">Sh</h2><article><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">Basic Project Structure: Folder layout for backend and frontend.</p><p style="text-align: left;">Backend Foundation (FastAPI): Setup, basic API structure, CORS.</p><p style="text-align: left;">Core Logic Examples: Implementation for 1-2 key features (e.g., Sentiment Analysis as a simple request, Image Generation showing background tasks) using the Hugging Face Inference API.</p><p style="text-align: left;">Frontend Foundation (React): Basic setup, component structure, example API calls.</p><p style="text-align: left;">Placeholders &#38; TODOs: Indicate where the other features, database integration, authentication, advanced error handling, deployment configurations, etc., would go.</p><p style="text-align: left;">This will give you a runnable skeleton that demonstrates the core concepts and architecture, which you or a developer can then build upon.</p><p style="text-align: left;"></p><p style="text-align: left;">Let&#39;s build this foundational skeleton:</p><p style="text-align: left;"></p><p style="text-align: left;">1. Project Structure</p><p style="text-align: left;"></p><p style="text-align: left;">neuralblitz-webapp/</p><p style="text-align: left;">├── backend/</p><p style="text-align: left;">│   ├── venv/                 # Virtual environment (created by you)</p><p style="text-align: left;">│   ├── app/</p><p style="text-align: left;">│   │   ├── __init__.py</p><p style="text-align: left;">│   │   ├── main.py           # FastAPI app setup, CORS</p><p style="text-align: left;">│   │   ├── models.py         # Pydantic models for requests/responses</p><p style="text-align: left;">│   │   ├── api.py            # API endpoint definitions</p><p style="text-align: left;">│   │   ├── services.py       # Logic for calling HF API, background tasks</p><p style="text-align: left;">│   │   └── tasks.py          # Background task definitions (conceptual for now)</p><p style="text-align: left;">│   ├── .env                  # Environment variables (HF Token) - YOU CREATE THIS</p><p style="text-align: left;">│   ├── requirements.txt      # Python dependencies</p><p style="text-align: left;">│   └── ...</p><p style="text-align: left;">└── frontend/</p><p style="text-align: left;">    ├── node_modules/         # Node modules (created by npm/yarn)</p><p style="text-align: left;">    ├── public/</p><p style="text-align: left;">    ├── src/</p><p style="text-align: left;">    │   ├── components/       # React components (Summarizer, ImageGenerator, etc.)</p><p style="text-align: left;">    │   ├── services/         # API call functions (e.g., apiService.js)</p><p style="text-align: left;">    │   ├── App.js            # Main application component</p><p style="text-align: left;">    │   ├── index.js          # Entry point</p><p style="text-align: left;">    │   └── ...</p><p style="text-align: left;">    ├── .env                  # Frontend env vars (optional) - YOU CREATE THIS</p><p style="text-align: left;">    ├── package.json</p><p style="text-align: left;">    └── ...</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">2. Backend Code (FastAPI)</p><p style="text-align: left;"></p><p style="text-align: left;">(a) backend/requirements.txt</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi</p><p style="text-align: left;">uvicorn[standard]</p><p style="text-align: left;">requests</p><p style="text-align: left;">python-dotenv</p><p style="text-align: left;">pydantic</p><p style="text-align: left;">python-multipart # For potential file uploads later</p><p style="text-align: left;"># Add later for more features:</p><p style="text-align: left;"># sqlalchemy[asyncio]</p><p style="text-align: left;"># psycopg2-binary # Or databases[sqlite]</p><p style="text-align: left;"># fastapi-users[sqlalchemy]</p><p style="text-align: left;"># python-jose[cryptography]</p><p style="text-align: left;"># celery[redis]</p><p style="text-align: left;"># redis[hiredis]</p><p style="text-align: left;"># Pillow</p><p style="text-align: left;"># pydub</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">(b) backend/.env (YOU CREATE THIS FILE)</p><p style="text-align: left;"></p><p style="text-align: left;">HUGGINGFACE_API_TOKEN=&#34;hf_YOUR_ACTUAL_HUGGINGFACE_TOKEN&#34;</p><p style="text-align: left;"># Add later: DATABASE_URL, JWT_SECRET_KEY, REDIS_URL etc.</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Replace hf_YOUR_ACTUAL_HUGGINGFACE_TOKEN with your real token. DO NOT COMMIT THIS FILE TO GIT.</p><p style="text-align: left;"></p><p style="text-align: left;">(c) backend/app/models.py</p><p style="text-align: left;"></p><p style="text-align: left;">from pydantic import BaseModel, Field</p><p style="text-align: left;">from typing import List, Optional, Dict, Any</p><p style="text-align: left;"></p><p style="text-align: left;">class TextInput(BaseModel):</p><p style="text-align: left;">    text: str</p><p style="text-align: left;"></p><p style="text-align: left;">class TranslationRequest(BaseModel):</p><p style="text-align: left;">    text: str</p><p style="text-align: left;">    source_lang: str = &#34;en&#34;</p><p style="text-align: left;">    target_lang: str = &#34;fr&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">class ImageGenRequest(BaseModel):</p><p style="text-align: left;">    prompt: str</p><p style="text-align: left;">    negative_prompt: Optional[str] = None</p><p style="text-align: left;">    # Add other params like guidance_scale etc. if needed</p><p style="text-align: left;"></p><p style="text-align: left;">class DocQARequest(BaseModel):</p><p style="text-align: left;">    context: str</p><p style="text-align: left;">    question: str</p><p style="text-align: left;"></p><p style="text-align: left;">class ZeroShotRequest(BaseModel):</p><p style="text-align: left;">    text: str</p><p style="text-align: left;">    candidate_labels: List[str]</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Response Models ---</p><p style="text-align: left;"></p><p style="text-align: left;">class SummaryResponse(BaseModel):</p><p style="text-align: left;">    summary: str</p><p style="text-align: left;"></p><p style="text-align: left;">class TranslationResponse(BaseModel):</p><p style="text-align: left;">    translation: str</p><p style="text-align: left;"></p><p style="text-align: left;">class SentimentResponse(BaseModel):</p><p style="text-align: left;">    label: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskResponse(BaseModel):</p><p style="text-align: left;">    task_id: str</p><p style="text-align: left;">    status: str = &#34;PENDING&#34;</p><p style="text-align: left;">    message: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class ImageGenResult(BaseModel):</p><p style="text-align: left;">    image_base64: Optional[str] = None # Base64 encoded image</p><p style="text-align: left;">    error: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class TranscriptionResult(BaseModel):</p><p style="text-align: left;">    transcription: Optional[str] = None</p><p style="text-align: left;">    error: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class CodeGenResult(BaseModel):</p><p style="text-align: left;">    generated_code: Optional[str] = None</p><p style="text-align: left;">    error: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskStatusResponse(BaseModel):</p><p style="text-align: left;">    task_id: str</p><p style="text-align: left;">    status: str # PENDING, SUCCESS, FAILURE</p><p style="text-align: left;">    result: Optional[Dict[str, Any]] = None # Holds specific result on success</p><p style="text-align: left;">    error: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class ZeroShotResponse(BaseModel):</p><p style="text-align: left;">    sequence: str</p><p style="text-align: left;">    labels: List[str]</p><p style="text-align: left;">    scores: List[float]</p><p style="text-align: left;"></p><p style="text-align: left;">class NerEntity(BaseModel):</p><p style="text-align: left;">    entity_group: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;">    word: str</p><p style="text-align: left;">    start: int</p><p style="text-align: left;">    end: int</p><p style="text-align: left;"></p><p style="text-align: left;">class NerResponse(BaseModel):</p><p style="text-align: left;">    entities: List[NerEntity]</p><p style="text-align: left;"></p><p style="text-align: left;">class QAResponse(BaseModel):</p><p style="text-align: left;">    answer: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;">    start: int</p><p style="text-align: left;">    end: int</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Generic Error ---</p><p style="text-align: left;">class ErrorResponse(BaseModel):</p><p style="text-align: left;">    detail: str</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(d) backend/app/services.py</p><p style="text-align: left;"></p><p style="text-align: left;">import requests</p><p style="text-align: left;">import os</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">import time</p><p style="text-align: left;">from fastapi import BackgroundTasks, HTTPException</p><p style="text-align: left;">from dotenv import load_dotenv</p><p style="text-align: left;">from typing import Dict, Any</p><p style="text-align: left;"></p><p style="text-align: left;">load_dotenv() # Load variables from .env file</p><p style="text-align: left;"></p><p style="text-align: left;">HF_API_TOKEN = os.getenv(&#34;HUGGINGFACE_API_TOKEN&#34;)</p><p style="text-align: left;">if not HF_API_TOKEN:</p><p style="text-align: left;">    print(&#34;ERROR: HUGGINGFACE_API_TOKEN not found in .env file.&#34;)</p><p style="text-align: left;">    # In a real app, raise an exception or handle this more gracefully</p><p style="text-align: left;">    # For demonstration, we proceed but API calls will fail without a token.</p><p style="text-align: left;"></p><p style="text-align: left;">HEADERS = {&#34;Authorization&#34;: f&#34;Bearer {HF_API_TOKEN}&#34;}</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Simple, Synchronous HF API Call Helper ---</p><p style="text-align: left;">def query_hf_inference_api(model_id: str, payload: Dict[str, Any]) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Makes a direct request to the HF Inference API.&#34;&#34;&#34;</p><p style="text-align: left;">    api_url = f&#34;https://api-inference.huggingface.co/models/{model_id}&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        response = requests.post(api_url, headers=HEADERS, json=payload)</p><p style="text-align: left;">        # Handle specific HF errors (e.g., model loading)</p><p style="text-align: left;">        if response.status_code == 503: # Model loading</p><p style="text-align: left;">             raise HTTPException(status_code=503, detail=f&#34;Model {model_id} is loading, please try again later. Response: {response.text}&#34;)</p><p style="text-align: left;">        response.raise_for_status() # Raise HTTP errors for other codes (4xx, 5xx)</p><p style="text-align: left;">        return response.json()</p><p style="text-align: left;">    except requests.exceptions.RequestException as e:</p><p style="text-align: left;">        print(f&#34;API Request failed for {model_id}: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Hugging Face API request failed: {e}&#34;)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;An unexpected error occurred calling {model_id}: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;An unexpected error occurred: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Background Task Simulation ---</p><p style="text-align: left;"># In a real app, use Celery + Redis/RabbitMQ for robustness.</p><p style="text-align: left;"># This is a simplified simulation using a dictionary as a task store.</p><p style="text-align: left;"># WARNING: This is NOT production-ready (in-memory, not persistent, no retries)</p><p style="text-align: left;">task_store: Dict[str, Dict[str, Any]] = {}</p><p style="text-align: left;"></p><p style="text-align: left;">def _run_long_task(task_id: str, model_id: str, payload: Dict[str, Any], result_key: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Simulates running a long inference task.&#34;&#34;&#34;</p><p style="text-align: left;">    global task_store</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Simulate network/processing time</p><p style="text-align: left;">        print(f&#34;Starting simulated long task {task_id} for model {model_id}...&#34;)</p><p style="text-align: left;">        # time.sleep(10) # Uncomment to simulate delay</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Actual HF API call for the long task</p><p style="text-align: left;">        api_url = f&#34;https://api-inference.huggingface.co/models/{model_id}&#34;</p><p style="text-align: left;">        response = requests.post(api_url, headers=HEADERS, json=payload)</p><p style="text-align: left;"></p><p style="text-align: left;">        # Handle model loading specifically for potentially slow models</p><p style="text-align: left;">        if response.status_code == 503:</p><p style="text-align: left;">            task_store[task_id] = {&#34;status&#34;: &#34;FAILURE&#34;, &#34;error&#34;: f&#34;Model {model_id} is still loading or unavailable.&#34;}</p><p style="text-align: left;">            print(f&#34;Task {task_id} failed: Model loading.&#34;)</p><p style="text-align: left;">            return</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Handle image responses (often return bytes, not JSON)</p><p style="text-align: left;">        if response.headers.get(&#39;Content-Type&#39;, &#39;&#39;).startswith(&#39;image/&#39;):</p><p style="text-align: left;">             if response.ok:</p><p style="text-align: left;">                import base64</p><p style="text-align: left;">                image_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                task_store[task_id] = {&#34;status&#34;: &#34;SUCCESS&#34;, &#34;result&#34;: {result_key: image_base64}}</p><p style="text-align: left;">                print(f&#34;Task {task_id} (Image) succeeded.&#34;)</p><p style="text-align: left;">             else:</p><p style="text-align: left;">                task_store[task_id] = {&#34;status&#34;: &#34;FAILURE&#34;, &#34;error&#34;: f&#34;API Error {response.status_code}: {response.text}&#34;}</p><p style="text-align: left;">                print(f&#34;Task {task_id} (Image) failed: {response.status_code}&#34;)</p><p style="text-align: left;">        # Handle JSON responses for other tasks</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            response.raise_for_status() # Check for other HTTP errors</p><p style="text-align: left;">            result_data = response.json()</p><p style="text-align: left;">            # Store the relevant part of the response based on the task</p><p style="text-align: left;">            # Need to inspect actual API responses to map correctly</p><p style="text-align: left;">            final_result = {}</p><p style="text-align: left;">            if isinstance(result_data, list) and result_data:</p><p style="text-align: left;">                 final_result = {result_key: result_data[0].get(result_key, result_data[0])} # Heuristic guess</p><p style="text-align: left;">            elif isinstance(result_data, dict):</p><p style="text-align: left;">                 final_result = {result_key: result_data.get(result_key, result_data)} # Heuristic guess</p><p style="text-align: left;">            else:</p><p style="text-align: left;">                 final_result = {result_key: result_data}</p><p style="text-align: left;"></p><p style="text-align: left;">            task_store[task_id] = {&#34;status&#34;: &#34;SUCCESS&#34;, &#34;result&#34;: final_result }</p><p style="text-align: left;">            print(f&#34;Task {task_id} succeeded.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">    except requests.exceptions.RequestException as e:</p><p style="text-align: left;">        task_store[task_id] = {&#34;status&#34;: &#34;FAILURE&#34;, &#34;error&#34;: f&#34;API Request failed: {e}&#34;}</p><p style="text-align: left;">        print(f&#34;Task {task_id} failed: {e}&#34;)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        task_store[task_id] = {&#34;status&#34;: &#34;FAILURE&#34;, &#34;error&#34;: f&#34;Unexpected error: {e}&#34;}</p><p style="text-align: left;">        print(f&#34;Task {task_id} failed unexpectedly: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_background_inference_task(</p><p style="text-align: left;">    background_tasks: BackgroundTasks,</p><p style="text-align: left;">    model_id: str,</p><p style="text-align: left;">    payload: Dict[str, Any],</p><p style="text-align: left;">    result_key: str # e.g., &#39;generated_text&#39;, &#39;summary_text&#39;, &#39;image_base64&#39;</p><p style="text-align: left;">) -&#62; str:</p><p style="text-align: left;">    &#34;&#34;&#34;Adds a task to run HF inference in the background.&#34;&#34;&#34;</p><p style="text-align: left;">    global task_store</p><p style="text-align: left;">    task_id = str(uuid.uuid4())</p><p style="text-align: left;">    task_store[task_id] = {&#34;status&#34;: &#34;PENDING&#34;}</p><p style="text-align: left;">    background_tasks.add_task(_run_long_task, task_id, model_id, payload, result_key)</p><p style="text-align: left;">    print(f&#34;Task {task_id} added to background queue for model {model_id}&#34;)</p><p style="text-align: left;">    return task_id</p><p style="text-align: left;"></p><p style="text-align: left;">def get_task_status(task_id: str) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets the status and result of a background task.&#34;&#34;&#34;</p><p style="text-align: left;">    global task_store</p><p style="text-align: left;">    status = task_store.get(task_id)</p><p style="text-align: left;">    if not status:</p><p style="text-align: left;">        raise HTTPException(status_code=404, detail=&#34;Task ID not found&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    # Clean up completed tasks after retrieval (optional, simple cleanup)</p><p style="text-align: left;">    # if status[&#34;status&#34;] in [&#34;SUCCESS&#34;, &#34;FAILURE&#34;]:</p><p style="text-align: left;">    #     # Consider adding a timestamp and cleaning up older tasks periodically</p><p style="text-align: left;">    #     # Be careful with concurrent access if not using thread-safe structures</p><p style="text-align: left;">    #     pass # For now, keep results in memory for simplicity</p><p style="text-align: left;">        </p><p style="text-align: left;">    return {&#34;task_id&#34;: task_id, **status}</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(e) backend/app/api.py</p><p style="text-align: left;"></p><p style="text-align: left;">from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends</p><p style="text-align: left;">from . import models</p><p style="text-align: left;">from . import services</p><p style="text-align: left;"># TODO: Add authentication dependencies later</p><p style="text-align: left;"># from .auth import get_current_active_user </p><p style="text-align: left;"># from .models import User</p><p style="text-align: left;"></p><p style="text-align: left;">router = APIRouter()</p><p style="text-align: left;"></p><p style="text-align: left;"># Simple synchronous endpoint example</p><p style="text-align: left;">@router.post(&#34;/api/sentiment&#34;, response_model=models.SentimentResponse)</p><p style="text-align: left;"># async def analyze_sentiment(data: models.TextInput, current_user: User = Depends(get_current_active_user)): # TODO: Add auth</p><p style="text-align: left;">async def analyze_sentiment(data: models.TextInput):</p><p style="text-align: left;">    &#34;&#34;&#34;Analyzes sentiment using a suitable HF model.&#34;&#34;&#34;</p><p style="text-align: left;">    # Example model - choose one appropriate for general sentiment</p><p style="text-align: left;">    model_id = &#34;distilbert-base-uncased-finetuned-sst-2-english&#34; </p><p style="text-align: left;">    payload = {&#34;inputs&#34;: data.text}</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        result = services.query_hf_inference_api(model_id, payload)</p><p style="text-align: left;">        # Response structure for this model is often like [[{&#39;label&#39;: &#39;POSITIVE&#39;, &#39;score&#39;: 0.99...}]]</p><p style="text-align: left;">        if result and isinstance(result, list) and result[0] and isinstance(result[0], list) and result[0][0]:</p><p style="text-align: left;">             sentiment = result[0][0]</p><p style="text-align: left;">             return models.SentimentResponse(label=sentiment.get(&#34;label&#34;, &#34;UNKNOWN&#34;), score=sentiment.get(&#34;score&#34;, 0.0))</p><p style="text-align: left;">        else:</p><p style="text-align: left;">             # Handle unexpected response structure</p><p style="text-align: left;">             print(f&#34;Unexpected sentiment response format: {result}&#34;)</p><p style="text-align: left;">             raise HTTPException(status_code=500, detail=&#34;Could not parse sentiment response from HF API&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e # Re-raise HTTP exceptions from the service</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error in sentiment endpoint: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=&#34;Internal server error during sentiment analysis.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># Background task example endpoint</p><p style="text-align: left;">@router.post(&#34;/api/generate-image&#34;, response_model=models.TaskResponse)</p><p style="text-align: left;"># async def generate_image(data: models.ImageGenRequest, background_tasks: BackgroundTasks, current_user: User = Depends(get_current_active_user)): # TODO: Add auth</p><p style="text-align: left;">async def generate_image(data: models.ImageGenRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts a background task to generate an image.&#34;&#34;&#34;</p><p style="text-align: left;">    # Example model - choose a suitable one, Stable Diffusion is common but demanding</p><p style="text-align: left;">    model_id = &#34;stabilityai/stable-diffusion-xl-base-1.0&#34; # Or runwayml/stable-diffusion-v1-5 etc.</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: data.prompt}</p><p style="text-align: left;">    if data.negative_prompt:</p><p style="text-align: left;">         payload[&#34;parameters&#34;] = {&#34;negative_prompt&#34;: data.negative_prompt} # API structure might vary</p><p style="text-align: left;">    </p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_background_inference_task(</p><p style="text-align: left;">             background_tasks,</p><p style="text-align: left;">             model_id,</p><p style="text-align: left;">             payload,</p><p style="text-align: left;">             result_key=&#34;image_base64&#34; # Key where the service should store the result</p><p style="text-align: left;">         )</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting image generation task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=&#34;Failed to start image generation task.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@router.get(&#34;/api/task-status/{task_id}&#34;, response_model=models.TaskStatusResponse)</p><p style="text-align: left;"># async def get_task_status_endpoint(task_id: str, current_user: User = Depends(get_current_active_user)): # TODO: Add auth</p><p style="text-align: left;">async def get_task_status_endpoint(task_id: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Polls for the status and result of a background task.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        status_data = services.get_task_status(task_id)</p><p style="text-align: left;">        # Map the internal result structure to the response model if needed</p><p style="text-align: left;">        # For images, the &#39;result&#39; dict in status_data should contain {&#39;image_base64&#39;: &#39;...&#39;}</p><p style="text-align: left;">        return models.TaskStatusResponse(**status_data)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error getting task status for {task_id}: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=&#34;Internal server error retrieving task status.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Stubs for other endpoints ---</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/summarize&#34;, response_model=models.TaskResponse) # Treat as potentially long task</p><p style="text-align: left;">async def summarize_text(data: models.TextInput, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    model_id = &#34;facebook/bart-large-cnn&#34; # Example</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: data.text, &#34;parameters&#34;: {&#34;min_length&#34;: 30, &#34;max_length&#34;: 150}} # Add parameters</p><p style="text-align: left;">    task_id = services.start_background_inference_task(background_tasks, model_id, payload, result_key=&#34;summary_text&#34;)</p><p style="text-align: left;">    return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/translate&#34;, response_model=models.TaskResponse) # Treat as potentially long task</p><p style="text-align: left;">async def translate_text(data: models.TranslationRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    # Basic model selection - enhance later</p><p style="text-align: left;">    model_id = f&#34;Helsinki-NLP/opus-mt-{data.source_lang}-{data.target_lang}&#34;</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: data.text}</p><p style="text-align: left;">    task_id = services.start_background_inference_task(background_tasks, model_id, payload, result_key=&#34;translation_text&#34;)</p><p style="text-align: left;">    return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/qa-document&#34;, response_model=models.TaskResponse) # Treat as potentially long task</p><p style="text-align: left;">async def qa_document(data: models.DocQARequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">     # TODO: Handle potential large context - chunking needed for production</p><p style="text-align: left;">     model_id = &#34;deepset/roberta-base-squad2&#34; # Example</p><p style="text-align: left;">     payload = {&#34;inputs&#34;: {&#34;question&#34;: data.question, &#34;context&#34;: data.context}}</p><p style="text-align: left;">     task_id = services.start_background_inference_task(background_tasks, model_id, payload, result_key=&#34;answer&#34;) # API response keys vary! Check model card.</p><p style="text-align: left;">     return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add endpoints for /transcribe, /text-to-speech, /generate-code, /classify-zero-shot, /extract-entities</p><p style="text-align: left;"># TODO: Add endpoints for saving results, fetching history (linked to user auth)</p><p style="text-align: left;"># TODO: Add database interaction logic</p><p style="text-align: left;"># TODO: Implement actual Celery tasks if using that instead of BackgroundTasks</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(f) backend/app/main.py</p><p style="text-align: left;"></p><p style="text-align: left;">from fastapi import FastAPI</p><p style="text-align: left;">from fastapi.middleware.cors import CORSMiddleware</p><p style="text-align: left;">from . import api # Import the router</p><p style="text-align: left;"></p><p style="text-align: left;">app = FastAPI(title=&#34;NeuralBlitz Multi-Tool AI&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># Configure CORS</p><p style="text-align: left;">origins = [</p><p style="text-align: left;">    &#34;http://localhost:3000&#34;,  # Allow frontend dev server</p><p style="text-align: left;">    # Add your deployed frontend URL here later, e.g., &#34;https://your-app-domain.com&#34;</p><p style="text-align: left;">]</p><p style="text-align: left;"></p><p style="text-align: left;">app.add_middleware(</p><p style="text-align: left;">    CORSMiddleware,</p><p style="text-align: left;">    allow_origins=origins,</p><p style="text-align: left;">    allow_credentials=True,</p><p style="text-align: left;">    allow_methods=[&#34;*&#34;],</p><p style="text-align: left;">    allow_headers=[&#34;*&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Include the API router</p><p style="text-align: left;">app.include_router(api.router)</p><p style="text-align: left;"></p><p style="text-align: left;">@app.get(&#34;/&#34;)</p><p style="text-align: left;">async def read_root():</p><p style="text-align: left;">    return {&#34;message&#34;: &#34;Welcome to the NeuralBlitz AI Backend!&#34;}</p><p style="text-align: left;"></p><p style="text-align: left;"># Add startup/shutdown events for database connections later if needed</p><p style="text-align: left;"># @app.on_event(&#34;startup&#34;)</p><p style="text-align: left;"># async def startup():</p><p style="text-align: left;">#     await database.connect()</p><p style="text-align: left;"></p><p style="text-align: left;"># @app.on_event(&#34;shutdown&#34;)</p><p style="text-align: left;"># async def shutdown():</p><p style="text-align: left;">#     await database.disconnect()</p><p style="text-align: left;"></p><p style="text-align: left;"># If using Uvicorn directly (for development):</p><p style="text-align: left;"># if __name__ == &#34;__main__&#34;:</p><p style="text-align: left;">#     import uvicorn</p><p style="text-align: left;">#     uvicorn.run(app, host=&#34;0.0.0.0&#34;, port=8000)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">3. Frontend Code (React Skeleton)</p><p style="text-align: left;"></p><p style="text-align: left;">(a) frontend/src/App.js</p><p style="text-align: left;"></p><p style="text-align: left;">import React, { useState } from &#39;react&#39;;</p><p style="text-align: left;">import &#39;./App.css&#39;;</p><p style="text-align: left;">import SentimentAnalyzer from &#39;./components/SentimentAnalyzer&#39;;</p><p style="text-align: left;">import ImageGenerator from &#39;./components/ImageGenerator&#39;;</p><p style="text-align: left;">// Import other components as you build them</p><p style="text-align: left;">// import Summarizer from &#39;./components/Summarizer&#39;;</p><p style="text-align: left;">// import Translator from &#39;./components/Translator&#39;;</p><p style="text-align: left;">// import DocQA from &#39;./components/DocQA&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">function App() {</p><p style="text-align: left;">  // Basic state to switch components - replace with router later</p><p style="text-align: left;">  const [activeTool, setActiveTool] = useState(&#39;sentiment&#39;); </p><p style="text-align: left;"></p><p style="text-align: left;">  const renderTool = () =&#62; {</p><p style="text-align: left;">    switch (activeTool) {</p><p style="text-align: left;">      case &#39;sentiment&#39;:</p><p style="text-align: left;">        return &#60;SentimentAnalyzer /&#62;;</p><p style="text-align: left;">      case &#39;imageGen&#39;:</p><p style="text-align: left;">         return &#60;ImageGenerator /&#62;;</p><p style="text-align: left;">      // case &#39;summarizer&#39;:</p><p style="text-align: left;">      //   return &#60;Summarizer /&#62;;</p><p style="text-align: left;">      // case &#39;translator&#39;:</p><p style="text-align: left;">      //    return &#60;Translator /&#62;;</p><p style="text-align: left;">      // case &#39;docQA&#39;:</p><p style="text-align: left;">      //    return &#60;DocQA /&#62;;</p><p style="text-align: left;">      default:</p><p style="text-align: left;">        return &#60;p&#62;Select a tool.&#60;/p&#62;;</p><p style="text-align: left;">    }</p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;div className=&#34;App&#34;&#62;</p><p style="text-align: left;">      &#60;header className=&#34;App-header&#34;&#62;</p><p style="text-align: left;">        &#60;h1&#62;NeuralBlitz AI Tools&#60;/h1&#62;</p><p style="text-align: left;">        {/* Simple navigation - replace with proper NavBar/Router */}</p><p style="text-align: left;">        &#60;nav&#62;</p><p style="text-align: left;">           &#60;button onClick={() =&#62; setActiveTool(&#39;sentiment&#39;)} disabled={activeTool === &#39;sentiment&#39;}&#62;Sentiment&#60;/button&#62;</p><p style="text-align: left;">           &#60;button onClick={() =&#62; setActiveTool(&#39;imageGen&#39;)} disabled={activeTool === &#39;imageGen&#39;}&#62;Image Gen&#60;/button&#62;</p><p style="text-align: left;">           {/* Add buttons for other tools */}</p><p style="text-align: left;">        &#60;/nav&#62;</p><p style="text-align: left;">      &#60;/header&#62;</p><p style="text-align: left;">      &#60;main&#62;</p><p style="text-align: left;">        {renderTool()}</p><p style="text-align: left;">      &#60;/main&#62;</p><p style="text-align: left;">      &#60;footer&#62;</p><p style="text-align: left;">         {/* Add footer content */}</p><p style="text-align: left;">      &#60;/footer&#62;</p><p style="text-align: left;">    &#60;/div&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default App;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(b) frontend/src/components/SentimentAnalyzer.js</p><p style="text-align: left;"></p><p style="text-align: left;">import React, { useState } from &#39;react&#39;;</p><p style="text-align: left;">import &#39;./Components.css&#39;; // Basic CSS file</p><p style="text-align: left;"></p><p style="text-align: left;">// Define your backend API URL (use environment variables in real app)</p><p style="text-align: left;">const API_BASE_URL = process.env.REACT_APP_API_URL || &#39;http://localhost:8000&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">function SentimentAnalyzer() {</p><p style="text-align: left;">  const [inputText, setInputText] = useState(&#39;&#39;);</p><p style="text-align: left;">  const [result, setResult] = useState(null);</p><p style="text-align: left;">  const [isLoading, setIsLoading] = useState(false);</p><p style="text-align: left;">  const [error, setError] = useState(null);</p><p style="text-align: left;"></p><p style="text-align: left;">  const handleSubmit = async (event) =&#62; {</p><p style="text-align: left;">    event.preventDefault(); // Prevent default form submission if using forms</p><p style="text-align: left;">    setIsLoading(true);</p><p style="text-align: left;">    setError(null);</p><p style="text-align: left;">    setResult(null);</p><p style="text-align: left;"></p><p style="text-align: left;">    try {</p><p style="text-align: left;">      const response = await fetch(`${API_BASE_URL}/api/sentiment`, {</p><p style="text-align: left;">        method: &#39;POST&#39;,</p><p style="text-align: left;">        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },</p><p style="text-align: left;">        body: JSON.stringify({ text: inputText }),</p><p style="text-align: left;">        // TODO: Add Authorization header if auth is implemented:</p><p style="text-align: left;">        // headers: { &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Authorization&#39;: `Bearer ${authToken}` },</p><p style="text-align: left;">      });</p><p style="text-align: left;"></p><p style="text-align: left;">      if (!response.ok) {</p><p style="text-align: left;">         const errorData = await response.json().catch(() =&#62; ({ detail: &#39;Unknown server error&#39; })); // Try to parse error</p><p style="text-align: left;">         throw new Error(`HTTP error ${response.status}: ${errorData.detail || response.statusText}`);</p><p style="text-align: left;">      }</p><p style="text-align: left;"></p><p style="text-align: left;">      const data = await response.json();</p><p style="text-align: left;">      setResult(data);</p><p style="text-align: left;"></p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      setError(err.message);</p><p style="text-align: left;">      console.error(&#34;Sentiment analysis error:&#34;, err);</p><p style="text-align: left;">    } finally {</p><p style="text-align: left;">      setIsLoading(false);</p><p style="text-align: left;">    }</p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;div className=&#34;ai-tool&#34;&#62;</p><p style="text-align: left;">      &#60;h2&#62;Sentiment Analysis&#60;/h2&#62;</p><p style="text-align: left;">      &#60;form onSubmit={handleSubmit}&#62;</p><p style="text-align: left;">        &#60;textarea</p><p style="text-align: left;">          value={inputText}</p><p style="text-align: left;">          onChange={(e) =&#62; setInputText(e.target.value)}</p><p style="text-align: left;">          rows=&#34;5&#34;</p><p style="text-align: left;">          placeholder=&#34;Enter text to analyze...&#34;</p><p style="text-align: left;">          required</p><p style="text-align: left;">        /&#62;</p><p style="text-align: left;">        &#60;br /&#62;</p><p style="text-align: left;">        &#60;button type=&#34;submit&#34; disabled={isLoading}&#62;</p><p style="text-align: left;">          {isLoading ? &#39;Analyzing...&#39; : &#39;Analyze Sentiment&#39;}</p><p style="text-align: left;">        &#60;/button&#62;</p><p style="text-align: left;">      &#60;/form&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">      {isLoading &#38;&#38; &#60;p&#62;Loading...&#60;/p&#62;}</p><p style="text-align: left;">      {error &#38;&#38; &#60;p className=&#34;error&#34;&#62;Error: {error}&#60;/p&#62;}</p><p style="text-align: left;">      {result &#38;&#38; (</p><p style="text-align: left;">        &#60;div className=&#34;result&#34;&#62;</p><p style="text-align: left;">          &#60;h3&#62;Result:&#60;/h3&#62;</p><p style="text-align: left;">          &#60;p&#62;Label: &#60;span className={`sentiment-${result.label?.toLowerCase()}`}&#62;{result.label}&#60;/span&#62;&#60;/p&#62;</p><p style="text-align: left;">          &#60;p&#62;Score: {result.score?.toFixed(3)}&#60;/p&#62;</p><p style="text-align: left;">        &#60;/div&#62;</p><p style="text-align: left;">      )}</p><p style="text-align: left;">    &#60;/div&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default SentimentAnalyzer;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(c) frontend/src/components/ImageGenerator.js</p><p style="text-align: left;"></p><p style="text-align: left;">import React, { useState, useEffect, useRef } from &#39;react&#39;;</p><p style="text-align: left;">import &#39;./Components.css&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">const API_BASE_URL = process.env.REACT_APP_API_URL || &#39;http://localhost:8000&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">function ImageGenerator() {</p><p style="text-align: left;">  const [prompt, setPrompt] = useState(&#39;&#39;);</p><p style="text-align: left;">  const [negativePrompt, setNegativePrompt] = useState(&#39;&#39;);</p><p style="text-align: left;">  const [taskId, setTaskId] = useState(null);</p><p style="text-align: left;">  const [status, setStatus] = useState(&#39;IDLE&#39;); // IDLE, PENDING, SUCCESS, FAILURE</p><p style="text-align: left;">  const [resultImage, setResultImage] = useState(null); // Base64 string</p><p style="text-align: left;">  const [error, setError] = useState(null);</p><p style="text-align: left;">  const intervalRef = useRef(null); // Ref to store interval ID</p><p style="text-align: left;"></p><p style="text-align: left;">  // Function to poll task status</p><p style="text-align: left;">  const pollStatus = async (currentTaskId) =&#62; {</p><p style="text-align: left;">    if (!currentTaskId) return;</p><p style="text-align: left;">    try {</p><p style="text-align: left;">      const response = await fetch(`${API_BASE_URL}/api/task-status/${currentTaskId}`);</p><p style="text-align: left;">      if (!response.ok) {</p><p style="text-align: left;">        // Handle 404 specifically if task expires or ID is wrong</p><p style="text-align: left;">        if (response.status === 404) {</p><p style="text-align: left;">           throw new Error(`Task ID ${currentTaskId} not found. It might have expired or is invalid.`);</p><p style="text-align: left;">        }</p><p style="text-align: left;">        const errorData = await response.json().catch(() =&#62; ({ detail: &#39;Unknown server error fetching status&#39; }));</p><p style="text-align: left;">        throw new Error(`HTTP error ${response.status}: ${errorData.detail || response.statusText}`);</p><p style="text-align: left;">      }</p><p style="text-align: left;">      const data = await response.json();</p><p style="text-align: left;"></p><p style="text-align: left;">      setStatus(data.status);</p><p style="text-align: left;"></p><p style="text-align: left;">      if (data.status === &#39;SUCCESS&#39;) {</p><p style="text-align: left;">        setResultImage(data.result?.image_base64); // Expecting image_base64 key</p><p style="text-align: left;">        setError(null);</p><p style="text-align: left;">        setTaskId(null); // Clear task ID on completion</p><p style="text-align: left;">        if (intervalRef.current) clearInterval(intervalRef.current); // Stop polling</p><p style="text-align: left;">      } else if (data.status === &#39;FAILURE&#39;) {</p><p style="text-align: left;">        setError(data.error || &#39;Image generation failed for unknown reason.&#39;);</p><p style="text-align: left;">        setTaskId(null); // Clear task ID on failure</p><p style="text-align: left;">        if (intervalRef.current) clearInterval(intervalRef.current); // Stop polling</p><p style="text-align: left;">      }</p><p style="text-align: left;">      // If PENDING, polling continues via setInterval</p><p style="text-align: left;"></p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      console.error(&#34;Polling error:&#34;, err);</p><p style="text-align: left;">      setError(`Failed to get task status: ${err.message}`);</p><p style="text-align: left;">      setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">      setTaskId(null);</p><p style="text-align: left;">      if (intervalRef.current) clearInterval(intervalRef.current); // Stop polling on error</p><p style="text-align: left;">    }</p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  // Effect to start/stop polling when taskId changes</p><p style="text-align: left;">  useEffect(() =&#62; {</p><p style="text-align: left;">    if (taskId &#38;&#38; status === &#39;PENDING&#39;) {</p><p style="text-align: left;">      // Clear any existing interval before starting a new one</p><p style="text-align: left;">      if (intervalRef.current) clearInterval(intervalRef.current);</p><p style="text-align: left;"></p><p style="text-align: left;">      // Poll immediately, then set interval</p><p style="text-align: left;">      pollStatus(taskId); </p><p style="text-align: left;">      intervalRef.current = setInterval(() =&#62; {</p><p style="text-align: left;">          pollStatus(taskId);</p><p style="text-align: left;">      }, 5000); // Poll every 5 seconds</p><p style="text-align: left;"></p><p style="text-align: left;">      // Cleanup function to clear interval when component unmounts or taskId changes</p><p style="text-align: left;">      return () =&#62; {</p><p style="text-align: left;">          if (intervalRef.current) {</p><p style="text-align: left;">              clearInterval(intervalRef.current);</p><p style="text-align: left;">              intervalRef.current = null; // Clear the ref</p><p style="text-align: left;">          }</p><p style="text-align: left;">      };</p><p style="text-align: left;">    } else if (status !== &#39;PENDING&#39; &#38;&#38; intervalRef.current) {</p><p style="text-align: left;">        // Ensure interval is cleared if status is no longer PENDING</p><p style="text-align: left;">        clearInterval(intervalRef.current);</p><p style="text-align: left;">        intervalRef.current = null;</p><p style="text-align: left;">    }</p><p style="text-align: left;">    // Dependency array includes taskId and status</p><p style="text-align: left;">  }, [taskId, status]); </p><p style="text-align: left;"></p><p style="text-align: left;">  const handleSubmit = async (event) =&#62; {</p><p style="text-align: left;">    event.preventDefault();</p><p style="text-align: left;">    setStatus(&#39;PENDING&#39;);</p><p style="text-align: left;">    setError(null);</p><p style="text-align: left;">    setResultImage(null);</p><p style="text-align: left;">    setTaskId(null); // Clear previous task ID</p><p style="text-align: left;">    if (intervalRef.current) clearInterval(intervalRef.current); // Clear previous interval</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">    const requestBody = { prompt };</p><p style="text-align: left;">    if (negativePrompt) {</p><p style="text-align: left;">      requestBody.negative_prompt = negativePrompt;</p><p style="text-align: left;">    }</p><p style="text-align: left;"></p><p style="text-align: left;">    try {</p><p style="text-align: left;">      const response = await fetch(`${API_BASE_URL}/api/generate-image`, {</p><p style="text-align: left;">        method: &#39;POST&#39;,</p><p style="text-align: left;">        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },</p><p style="text-align: left;">        body: JSON.stringify(requestBody),</p><p style="text-align: left;">        // TODO: Add Authorization header</p><p style="text-align: left;">      });</p><p style="text-align: left;"></p><p style="text-align: left;">      if (!response.ok) {</p><p style="text-align: left;">        const errorData = await response.json().catch(() =&#62; ({ detail: &#39;Failed to start task&#39; }));</p><p style="text-align: left;">        throw new Error(`HTTP error ${response.status}: ${errorData.detail || response.statusText}`);</p><p style="text-align: left;">      }</p><p style="text-align: left;">      const data = await response.json();</p><p style="text-align: left;">      setTaskId(data.task_id); // Start polling</p><p style="text-align: left;">      setStatus(&#39;PENDING&#39;); // Explicitly set status after getting task ID</p><p style="text-align: left;"></p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      setError(`Failed to start generation task: ${err.message}`);</p><p style="text-align: left;">      setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">      console.error(&#34;Submit error:&#34;, err);</p><p style="text-align: left;">    }</p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;div className=&#34;ai-tool&#34;&#62;</p><p style="text-align: left;">      &#60;h2&#62;Text-to-Image Generator&#60;/h2&#62;</p><p style="text-align: left;">      &#60;form onSubmit={handleSubmit}&#62;</p><p style="text-align: left;">        &#60;label htmlFor=&#34;prompt&#34;&#62;Prompt:&#60;/label&#62;&#60;br/&#62;</p><p style="text-align: left;">        &#60;textarea</p><p style="text-align: left;">          id=&#34;prompt&#34;</p><p style="text-align: left;">          value={prompt}</p><p style="text-align: left;">          onChange={(e) =&#62; setPrompt(e.target.value)}</p><p style="text-align: left;">          rows=&#34;3&#34;</p><p style="text-align: left;">          placeholder=&#34;Describe the image you want to create...&#34;</p><p style="text-align: left;">          required</p><p style="text-align: left;">        /&#62;&#60;br/&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">        &#60;label htmlFor=&#34;neg-prompt&#34;&#62;Negative Prompt (Optional):&#60;/label&#62;&#60;br/&#62;</p><p style="text-align: left;">        &#60;input</p><p style="text-align: left;">          id=&#34;neg-prompt&#34;</p><p style="text-align: left;">          type=&#34;text&#34;</p><p style="text-align: left;">          value={negativePrompt}</p><p style="text-align: left;">          onChange={(e) =&#62; setNegativePrompt(e.target.value)}</p><p style="text-align: left;">          placeholder=&#34;Things to avoid in the image...&#34;</p><p style="text-align: left;">        /&#62;&#60;br/&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">        &#60;button type=&#34;submit&#34; disabled={status === &#39;PENDING&#39;}&#62;</p><p style="text-align: left;">          {status === &#39;PENDING&#39; ? &#39;Generating...&#39; : &#39;Generate Image&#39;}</p><p style="text-align: left;">        &#60;/button&#62;</p><p style="text-align: left;">      &#60;/form&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">      {status === &#39;PENDING&#39; &#38;&#38; taskId &#38;&#38; &#60;p&#62;Generating image (Task ID: {taskId}). Please wait... Status will update automatically.&#60;/p&#62;}</p><p style="text-align: left;">      {error &#38;&#38; &#60;p className=&#34;error&#34;&#62;Error: {error}&#60;/p&#62;}</p><p style="text-align: left;">      {status === &#39;SUCCESS&#39; &#38;&#38; resultImage &#38;&#38; (</p><p style="text-align: left;">        &#60;div className=&#34;result&#34;&#62;</p><p style="text-align: left;">          &#60;h3&#62;Generated Image:&#60;/h3&#62;</p><p style="text-align: left;">          &#60;img src={`data:image/jpeg;base64,${resultImage}`} alt={prompt} /&#62;</p><p style="text-align: left;">        &#60;/div&#62;</p><p style="text-align: left;">      )}</p><p style="text-align: left;">       {status === &#39;SUCCESS&#39; &#38;&#38; !resultImage &#38;&#38; &#60;p className=&#34;error&#34;&#62;Generation succeeded but no image data received.&#60;/p&#62;}</p><p style="text-align: left;">    &#60;/div&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default ImageGenerator;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(d) frontend/src/components/Components.css (Very Basic Styling)</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool {</p><p style="text-align: left;">  border: 1px solid #ccc;</p><p style="text-align: left;">  padding: 20px;</p><p style="text-align: left;">  margin-bottom: 20px;</p><p style="text-align: left;">  border-radius: 8px;</p><p style="text-align: left;">  background-color: #f9f9f9;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool h2 {</p><p style="text-align: left;">  margin-top: 0;</p><p style="text-align: left;">  color: #333;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool textarea,</p><p style="text-align: left;">.ai-tool input[type=&#34;text&#34;] {</p><p style="text-align: left;">  width: 95%;</p><p style="text-align: left;">  padding: 10px;</p><p style="text-align: left;">  margin-bottom: 10px;</p><p style="text-align: left;">  border: 1px solid #ccc;</p><p style="text-align: left;">  border-radius: 4px;</p><p style="text-align: left;">  font-size: 1em;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool button {</p><p style="text-align: left;">  padding: 10px 20px;</p><p style="text-align: left;">  background-color: #007bff;</p><p style="text-align: left;">  color: white;</p><p style="text-align: left;">  border: none;</p><p style="text-align: left;">  border-radius: 4px;</p><p style="text-align: left;">  cursor: pointer;</p><p style="text-align: left;">  font-size: 1em;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool button:disabled {</p><p style="text-align: left;">  background-color: #ccc;</p><p style="text-align: left;">  cursor: not-allowed;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool .result {</p><p style="text-align: left;">  margin-top: 15px;</p><p style="text-align: left;">  padding: 15px;</p><p style="text-align: left;">  background-color: #e9e9e9;</p><p style="text-align: left;">  border: 1px solid #ddd;</p><p style="text-align: left;">  border-radius: 4px;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool .result h3 {</p><p style="text-align: left;">    margin-top: 0;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool .result img {</p><p style="text-align: left;">    max-width: 100%;</p><p style="text-align: left;">    height: auto;</p><p style="text-align: left;">    margin-top: 10px;</p><p style="text-align: left;">    border: 1px solid #ccc;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.ai-tool .error {</p><p style="text-align: left;">  color: red;</p><p style="text-align: left;">  font-weight: bold;</p><p style="text-align: left;">  margin-top: 10px;</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">.sentiment-positive { color: green; font-weight: bold;}</p><p style="text-align: left;">.sentiment-negative { color: orange; font-weight: bold;} /* Using orange for better visibility than red potentially */</p><p style="text-align: left;">.sentiment-neutral { color: grey; font-weight: bold;}</p><p style="text-align: left;">.sentiment-unknown { color: black; font-style: italic;}</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Css</p><p style="text-align: left;">(e) frontend/src/index.js and frontend/src/App.css (Standard Create React App files - modify App.css as needed)</p><p style="text-align: left;"></p><p style="text-align: left;">4. How to Run This Skeleton</p><p style="text-align: left;"></p><p style="text-align: left;">Setup Backend:</p><p style="text-align: left;">Navigate to backend/ directory.</p><p style="text-align: left;">Create virtual environment: python -m venv venv</p><p style="text-align: left;">Activate: source venv/bin/activate (Linux/macOS) or venv\Scripts\activate (Windows)</p><p style="text-align: left;">Install dependencies: pip install -r requirements.txt</p><p style="text-align: left;">Create .env file and add your HUGGINGFACE_API_TOKEN.</p><p style="text-align: left;">Run: uvicorn app.main:app --reload --port 8000</p><p style="text-align: left;">Setup Frontend:</p><p style="text-align: left;">Navigate to frontend/ directory.</p><p style="text-align: left;">Install dependencies: npm install (or yarn install)</p><p style="text-align: left;">(Optional) Create .env file if you need frontend-specific variables (like REACT_APP_API_URL=http://localhost:8000).</p><p style="text-align: left;">Run: npm start (or yarn start)</p><p style="text-align: left;">Access: Open http://localhost:3000 (or whatever port React starts on) in your browser.</p><p style="text-align: left;">5. Next Steps (Significant Work Required)</p><p style="text-align: left;"></p><p style="text-align: left;">Implement All Remaining Backend Endpoints: Follow the patterns above for Summarization, Translation, Doc Q&#38;A, Transcription, TTS, Code Gen, Zero-shot, NER. Remember to check the specific HF Inference API documentation for expected payloads and response structures for each model. Implement background tasks properly (Celery recommended for production).</p><p style="text-align: left;">Implement All Remaining Frontend Components: Create React components for each feature, handle their specific inputs/outputs, loading states, and errors.</p><p style="text-align: left;">Implement Database: Choose DB (PostgreSQL recommended), define SQLAlchemy models, set up Alembic migrations, add database interaction logic to backend endpoints (saving results, fetching history).</p><p style="text-align: left;">Implement Authentication: Integrate fastapi-users or similar, secure endpoints, manage tokens on frontend.</p><p style="text-align: left;">Refine UI/UX: Implement proper routing, navigation, layout, styling, accessibility.</p><p style="text-align: left;">Robust Error Handling: Add more specific error handling and user feedback on both frontend and backend.</p><p style="text-align: left;">Testing: Write unit, integration, and end-to-end tests.</p><p style="text-align: left;">Scalability: Migrate heavy models to HF Inference Endpoints as needed. Optimize queries, implement caching.</p><p style="text-align: left;">Deployment: Configure cloud infrastructure, CI/CD pipelines.</p><p style="text-align: left;">This codebase provides a solid foundation demonstrating the core architecture and interaction patterns. Building out the full application will require substantial development effort based on this skeleton.</p><p style="text-align: left;">Okay, let&#39;s significantly expand and improve upon the previous skeleton. This version will:</p><p style="text-align: left;"></p><p style="text-align: left;">Implement Backend Stubs for All Features: Create endpoints and basic service logic placeholders for all planned features (Summarization, Translation, Sentiment, Image Gen, Doc QA, Transcription, TTS, Code Gen, Zero-Shot Class., NER).</p><p style="text-align: left;">Use FastAPI BackgroundTasks: Replace the simple dictionary task store with FastAPI&#39;s built-in background task system. This is still not as robust as Celery for production but is a step closer and integrated directly.</p><p style="text-align: left;">Refine Models: Add more specific Pydantic models for requests and responses.</p><p style="text-align: left;">Basic Config: Introduce a simple config.py for settings.</p><p style="text-align: left;">Frontend Routing: Use react-router-dom for basic navigation.</p><p style="text-align: left;">Frontend Components: Create basic functional components for all features, showing input areas and result display areas. Implement the API calling logic more consistently.</p><p style="text-align: left;">Frontend API Service: Centralize backend calls.</p><p style="text-align: left;">More Comments &#38; TODOs: Clearly indicate where further development (DB, Auth, Real Background Tasks, Error Handling, etc.) is needed.</p><p style="text-align: left;">Remember: This is still a foundation, not a fully production-ready app. Features like database integration, user authentication, robust error handling, sophisticated state management, deployment configurations, and replacing BackgroundTasks with Celery/Redis are crucial next steps not fully implemented here.</p><p style="text-align: left;"></p><p style="text-align: left;">1. Project Structure (No Changes)</p><p style="text-align: left;"></p><p style="text-align: left;">(Same as before)</p><p style="text-align: left;"></p><p style="text-align: left;">2. Backend Code (Expanded)</p><p style="text-align: left;"></p><p style="text-align: left;">(a) backend/requirements.txt (Updated)</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi</p><p style="text-align: left;">uvicorn[standard]</p><p style="text-align: left;">requests</p><p style="text-align: left;">python-dotenv</p><p style="text-align: left;">pydantic</p><p style="text-align: left;">python-multipart</p><p style="text-align: left;"># Add later: sqlalchemy[asyncio], psycopg2-binary, fastapi-users[sqlalchemy], python-jose[cryptography], celery[redis], redis[hiredis], pypdf2, Pillow, pydub, langdetect</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">(b) backend/.env (YOU CREATE THIS FILE - Same as before)</p><p style="text-align: left;"></p><p style="text-align: left;">HUGGINGFACE_API_TOKEN=&#34;hf_YOUR_ACTUAL_HUGGINGFACE_TOKEN&#34;</p><p style="text-align: left;"># Add later: DATABASE_URL, JWT_SECRET_KEY, REDIS_URL etc.</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">(c) backend/app/config.py (NEW)</p><p style="text-align: left;"></p><p style="text-align: left;">import os</p><p style="text-align: left;">from dotenv import load_dotenv</p><p style="text-align: left;">from pydantic import BaseSettings</p><p style="text-align: left;"></p><p style="text-align: left;">load_dotenv()</p><p style="text-align: left;"></p><p style="text-align: left;">class Settings(BaseSettings):</p><p style="text-align: left;">    HF_API_TOKEN: str = os.getenv(&#34;HUGGINGFACE_API_TOKEN&#34;, &#34;YOUR_TOKEN_HERE&#34;) # Default helps avoid crashing if .env missed</p><p style="text-align: left;">    HF_API_BASE_URL: str = &#34;https://api-inference.huggingface.co/models/&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">    # --- Default Model IDs (Easily Changeable Here) ---</p><p style="text-align: left;">    MODEL_SUMMARIZATION: str = &#34;facebook/bart-large-cnn&#34;</p><p style="text-align: left;">    MODEL_TRANSLATION_PREFIX: str = &#34;Helsinki-NLP/opus-mt-&#34; # Append src-tgt</p><p style="text-align: left;">    MODEL_SENTIMENT: str = &#34;distilbert-base-uncased-finetuned-sst-2-english&#34;</p><p style="text-align: left;">    MODEL_IMAGE_GEN: str = &#34;stabilityai/stable-diffusion-xl-base-1.0&#34; # Resource intensive!</p><p style="text-align: left;">    MODEL_DOC_QA: str = &#34;deepset/roberta-base-squad2&#34;</p><p style="text-align: left;">    MODEL_TRANSCRIPTION: str = &#34;openai/whisper-large-v2&#34; # Resource intensive!</p><p style="text-align: left;">    MODEL_TTS: str = &#34;espnet/kan-bayashi_ljspeech_vits&#34; # Example, check availability</p><p style="text-align: left;">    MODEL_CODE_GEN: str = &#34;codellama/CodeLlama-7b-hf&#34; # Resource intensive!</p><p style="text-align: left;">    MODEL_ZERO_SHOT: str = &#34;facebook/bart-large-mnli&#34;</p><p style="text-align: left;">    MODEL_NER: str = &#34;dbmdz/bert-large-cased-finetuned-conll03-english&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">    # Placeholder for future DB/Auth settings</p><p style="text-align: left;">    # DATABASE_URL: str = &#34;postgresql+asyncpg://user:pass@host:port/db&#34;</p><p style="text-align: left;">    # JWT_SECRET_KEY: str = &#34;a_very_secret_key&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">settings = Settings()</p><p style="text-align: left;"></p><p style="text-align: left;"># Simple check if token seems missing during startup</p><p style="text-align: left;">if settings.HF_API_TOKEN == &#34;YOUR_TOKEN_HERE&#34; or not settings.HF_API_TOKEN:</p><p style="text-align: left;">     print(&#34;\n**************************************************************&#34;)</p><p style="text-align: left;">     print(&#34;WARNING: HUGGINGFACE_API_TOKEN is not set or invalid.&#34;)</p><p style="text-align: left;">     print(&#34;Please create a &#39;.env&#39; file in the &#39;backend&#39; directory with:&#34;)</p><p style="text-align: left;">     print(&#34;HUGGINGFACE_API_TOKEN=&#39;hf_YourActualToken&#39;&#34;)</p><p style="text-align: left;">     print(&#34;API calls to Hugging Face will likely fail.&#34;)</p><p style="text-align: left;">     print(&#34;**************************************************************\n&#34;)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(d) backend/app/models.py (Expanded)</p><p style="text-align: left;"></p><p style="text-align: left;">from pydantic import BaseModel, Field</p><p style="text-align: left;">from typing import List, Optional, Dict, Any, Union</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Request Models ---</p><p style="text-align: left;">class TextInput(BaseModel):</p><p style="text-align: left;">    text: str = Field(..., example=&#34;This is the text to process.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">class SummarizationRequest(TextInput):</p><p style="text-align: left;">    min_length: Optional[int] = 30</p><p style="text-align: left;">    max_length: Optional[int] = 150</p><p style="text-align: left;"></p><p style="text-align: left;">class TranslationRequest(BaseModel):</p><p style="text-align: left;">    text: str = Field(..., example=&#34;Hello world.&#34;)</p><p style="text-align: left;">    source_lang: Optional[str] = None # Optional: Some models might detect</p><p style="text-align: left;">    target_lang: str = Field(..., example=&#34;fr&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">class ImageGenRequest(BaseModel):</p><p style="text-align: left;">    prompt: str = Field(..., example=&#34;An astronaut riding a horse on the moon.&#34;)</p><p style="text-align: left;">    negative_prompt: Optional[str] = Field(None, example=&#34;low quality, blurry&#34;)</p><p style="text-align: left;">    # Add other params like guidance_scale etc. if needed</p><p style="text-align: left;"></p><p style="text-align: left;">class DocQARequest(BaseModel):</p><p style="text-align: left;">    context: str = Field(..., example=&#34;Jupiter is the fifth planet...&#34;)</p><p style="text-align: left;">    question: str = Field(..., example=&#34;What is the fifth planet?&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">class TextToSpeechRequest(TextInput):</p><p style="text-align: left;">    # Add model/speaker selection later if needed</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;">class CodeGenRequest(BaseModel):</p><p style="text-align: left;">    prompt: str = Field(..., example=&#34;Write a python function to calculate fibonacci.&#34;)</p><p style="text-align: left;">    language: str = Field(..., example=&#34;python&#34;)</p><p style="text-align: left;">    # Add parameters like max_tokens etc.</p><p style="text-align: left;"></p><p style="text-align: left;">class ZeroShotRequest(BaseModel):</p><p style="text-align: left;">    text: str = Field(..., example=&#34;I love this new phone!&#34;)</p><p style="text-align: left;">    candidate_labels: List[str] = Field(..., example=[&#34;technology&#34;, &#34;politics&#34;, &#34;food&#34;])</p><p style="text-align: left;"></p><p style="text-align: left;">class NerRequest(TextInput):</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;"># --- File Upload Model ---</p><p style="text-align: left;"># Handled directly by FastAPI UploadFile in endpoint</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Task Management Models ---</p><p style="text-align: left;">class TaskResponse(BaseModel):</p><p style="text-align: left;">    task_id: str</p><p style="text-align: left;">    status: str = &#34;ACCEPTED&#34; # Changed from PENDING to ACCEPTED for clarity</p><p style="text-align: left;">    message: Optional[str] = &#34;Task submitted for background processing.&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskStatusRequest(BaseModel):</p><p style="text-align: left;">    task_id: str</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskResult(BaseModel):</p><p style="text-align: left;">    # Use Union for flexible result types, refine later</p><p style="text-align: left;">    result_data: Optional[Union[str, float, int, list, dict, Any]] = None</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskStatusResponse(BaseModel):</p><p style="text-align: left;">    task_id: str</p><p style="text-align: left;">    status: str # PENDING, SUCCESS, FAILURE</p><p style="text-align: left;">    result: Optional[TaskResult] = None # Holds specific result on success</p><p style="text-align: left;">    error: Optional[str] = None</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Specific Result Payload Models (Nested within TaskStatusResponse) ---</p><p style="text-align: left;">class SummaryResult(BaseModel):</p><p style="text-align: left;">    summary_text: str</p><p style="text-align: left;"></p><p style="text-align: left;">class TranslationResult(BaseModel):</p><p style="text-align: left;">    translation_text: str</p><p style="text-align: left;"></p><p style="text-align: left;">class SentimentScore(BaseModel):</p><p style="text-align: left;">    label: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;"></p><p style="text-align: left;">class SentimentResult(BaseModel):</p><p style="text-align: left;">    sentiment: List[SentimentScore] # Some models return multiple labels/scores</p><p style="text-align: left;"></p><p style="text-align: left;">class ImageGenResult(BaseModel):</p><p style="text-align: left;">    image_base64: Optional[str] = None # Base64 encoded image</p><p style="text-align: left;"></p><p style="text-align: left;">class TranscriptionResult(BaseModel):</p><p style="text-align: left;">    transcription_text: str</p><p style="text-align: left;"></p><p style="text-align: left;">class TextToSpeechResult(BaseModel):</p><p style="text-align: left;">    audio_base64: Optional[str] = None # Base64 encoded audio (e.g., wav/mp3)</p><p style="text-align: left;"></p><p style="text-align: left;">class CodeGenResult(BaseModel):</p><p style="text-align: left;">    generated_code: str</p><p style="text-align: left;"></p><p style="text-align: left;">class ZeroShotResult(BaseModel):</p><p style="text-align: left;">    sequence: str</p><p style="text-align: left;">    labels: List[str]</p><p style="text-align: left;">    scores: List[float]</p><p style="text-align: left;"></p><p style="text-align: left;">class NerEntity(BaseModel):</p><p style="text-align: left;">    entity_group: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;">    word: str</p><p style="text-align: left;">    start: int</p><p style="text-align: left;">    end: int</p><p style="text-align: left;"></p><p style="text-align: left;">class NerResult(BaseModel):</p><p style="text-align: left;">    entities: List[NerEntity]</p><p style="text-align: left;"></p><p style="text-align: left;">class QAResult(BaseModel):</p><p style="text-align: left;">    answer: str</p><p style="text-align: left;">    score: float</p><p style="text-align: left;">    start: Optional[int] = None # Not always available</p><p style="text-align: left;">    end: Optional[int] = None</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Generic Error ---</p><p style="text-align: left;">class ErrorResponse(BaseModel):</p><p style="text-align: left;">    detail: str</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(e) backend/app/tasks.py (NEW - Background Task Logic)</p><p style="text-align: left;"></p><p style="text-align: left;">import requests</p><p style="text-align: left;">import os</p><p style="text-align: left;">import base64</p><p style="text-align: left;">import time</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">from typing import Dict, Any, Optional</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"></p><p style="text-align: left;"># WARNING: In-memory storage IS NOT SUITABLE FOR PRODUCTION.</p><p style="text-align: left;"># Replace with Redis/DB backed persistent storage.</p><p style="text-align: left;"># Also lacks proper locking for concurrent access.</p><p style="text-align: left;">task_storage: Dict[str, Dict[str, Any]] = {}</p><p style="text-align: left;"></p><p style="text-align: left;">HEADERS = {&#34;Authorization&#34;: f&#34;Bearer {settings.HF_API_TOKEN}&#34;}</p><p style="text-align: left;"></p><p style="text-align: left;">def _make_hf_request(model_id: str, payload: Dict[str, Any], is_image_output: bool = False, is_audio_output: bool = False) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Internal helper to make the actual HF API request and handle response types.&#34;&#34;&#34;</p><p style="text-align: left;">    api_url = f&#34;{settings.HF_API_BASE_URL}{model_id}&#34;</p><p style="text-align: left;">    result_payload = {}</p><p style="text-align: left;">    error_payload = None</p><p style="text-align: left;"></p><p style="text-align: left;">    try:</p><p style="text-align: left;">        print(f&#34;Making HF API call to: {api_url}&#34;)</p><p style="text-align: left;">        # Add timeout</p><p style="text-align: left;">        response = requests.post(api_url, headers=HEADERS, json=payload, timeout=180) # Increased timeout</p><p style="text-align: left;"></p><p style="text-align: left;">        content_type = response.headers.get(&#39;Content-Type&#39;, &#39;&#39;)</p><p style="text-align: left;"></p><p style="text-align: left;">        if response.status_code == 503: # Model loading</p><p style="text-align: left;">            error_payload = f&#34;Model {model_id} is loading, please try again later. Status: 503&#34;</p><p style="text-align: left;">            print(error_payload)</p><p style="text-align: left;">            return {&#34;error&#34;: error_payload}</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_image_output and content_type.startswith(&#39;image/&#39;):</p><p style="text-align: left;">            if response.ok:</p><p style="text-align: left;">                image_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;image_base64&#34;: image_base64}</p><p style="text-align: left;">                print(f&#34;Image received for model {model_id}&#34;)</p><p style="text-align: left;">            else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for image: {response.text}&#34;</p><p style="text-align: left;">                print(error_payload)</p><p style="text-align: left;">                result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_audio_output and content_type.startswith(&#39;audio/&#39;):</p><p style="text-align: left;">             if response.ok:</p><p style="text-align: left;">                audio_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;audio_base64&#34;: audio_base64} # Assuming base64 is desired</p><p style="text-align: left;">                print(f&#34;Audio received for model {model_id}&#34;)</p><p style="text-align: left;">             else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for audio: {response.text}&#34;</p><p style="text-align: left;">                print(error_payload)</p><p style="text-align: left;">                result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;">        </p><p style="text-align: left;">        elif content_type.startswith(&#39;application/json&#39;) or response.ok: # Check ok for non-json successes too</p><p style="text-align: left;">            # Try to parse JSON, but handle cases where it might not be JSON even on success</p><p style="text-align: left;">            try:</p><p style="text-align: left;">                result_data = response.json()</p><p style="text-align: left;">                response.raise_for_status() # Check for other HTTP errors *after* checking content type</p><p style="text-align: left;">                # The actual result might be nested, often in the first element of a list</p><p style="text-align: left;">                if isinstance(result_data, list) and result_data:</p><p style="text-align: left;">                    result_payload = result_data[0] # Common pattern, but may need adjustment per model</p><p style="text-align: left;">                elif isinstance(result_data, dict):</p><p style="text-align: left;">                     result_payload = result_data # Or extract specific keys</p><p style="text-align: left;">                else:</p><p style="text-align: left;">                     result_payload = {&#34;raw_response&#34;: result_data} # Fallback</p><p style="text-align: left;">                print(f&#34;JSON response received for model {model_id}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">            except requests.exceptions.JSONDecodeError:</p><p style="text-align: left;">                 # Handle cases where success code is returned but body isn&#39;t valid JSON</p><p style="text-align: left;">                 if response.ok:</p><p style="text-align: left;">                     error_payload = f&#34;Received non-JSON success response ({response.status_code}) from {model_id}. Body: {response.text[:100]}...&#34;</p><p style="text-align: left;">                     print(error_payload)</p><p style="text-align: left;">                     result_payload = {&#34;error&#34;: error_payload, &#34;raw_response&#34;: response.text}</p><p style="text-align: left;">                 else: # If not ok and not JSON, it&#39;s likely a text error message</p><p style="text-align: left;">                     error_payload = f&#34;API Error {response.status_code}: {response.text}&#34;</p><p style="text-align: left;">                     print(error_payload)</p><p style="text-align: left;">                     result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;">            except requests.exceptions.HTTPError as e:</p><p style="text-align: left;">                # If raise_for_status fails after JSON parse</p><p style="text-align: left;">                error_payload = f&#34;API HTTP Error {response.status_code}: {e}. Response: {result_data}&#34;</p><p style="text-align: left;">                print(error_payload)</p><p style="text-align: left;">                result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;">        else: # Handle other non-ok, non-image/audio/json cases</p><p style="text-align: left;">            error_payload = f&#34;API Error {response.status_code} with content-type &#39;{content_type}&#39;: {response.text}&#34;</p><p style="text-align: left;">            print(error_payload)</p><p style="text-align: left;">            result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">    except requests.exceptions.Timeout:</p><p style="text-align: left;">         error_payload = f&#34;API Request timed out for {model_id}&#34;</p><p style="text-align: left;">         print(error_payload)</p><p style="text-align: left;">         result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;">    except requests.exceptions.RequestException as e:</p><p style="text-align: left;">        error_payload = f&#34;API Request failed for {model_id}: {e}&#34;</p><p style="text-align: left;">        print(error_payload)</p><p style="text-align: left;">        result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        error_payload = f&#34;Unexpected error during API call for {model_id}: {type(e).__name__} - {e}&#34;</p><p style="text-align: left;">        print(error_payload)</p><p style="text-align: left;">        result_payload = {&#34;error&#34;: error_payload}</p><p style="text-align: left;"></p><p style="text-align: left;">    # Return a dictionary containing either the result or an error key</p><p style="text-align: left;">    return result_payload</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">def run_inference_task(task_id: str, model_id: str, payload: Dict[str, Any], task_type: str):</p><p style="text-align: left;">    &#34;&#34;&#34;The actual function executed by BackgroundTasks.&#34;&#34;&#34;</p><p style="text-align: left;">    global task_storage</p><p style="text-align: left;">    print(f&#34;Background task {task_id} ({task_type}) started for model {model_id}...&#34;)</p><p style="text-align: left;">    task_storage[task_id] = {&#34;status&#34;: &#34;PENDING&#34;} # Ensure status is PENDING</p><p style="text-align: left;"></p><p style="text-align: left;">    is_image = task_type == &#34;image_generation&#34;</p><p style="text-align: left;">    is_audio = task_type in [&#34;transcription&#34;, &#34;tts&#34;] # Adjust if transcribe returns JSON</p><p style="text-align: left;"></p><p style="text-align: left;">    # Simulate some work being done before the actual API call</p><p style="text-align: left;">    time.sleep(1) </p><p style="text-align: left;"></p><p style="text-align: left;">    # Make the API call using the helper</p><p style="text-align: left;">    result_or_error = _make_hf_request(model_id, payload, is_image_output=is_image, is_audio_output=is_audio)</p><p style="text-align: left;"></p><p style="text-align: left;">    # Update task storage based on outcome</p><p style="text-align: left;">    if &#34;error&#34; in result_or_error:</p><p style="text-align: left;">        task_storage[task_id] = {&#34;status&#34;: &#34;FAILURE&#34;, &#34;error&#34;: result_or_error[&#34;error&#34;]}</p><p style="text-align: left;">        print(f&#34;Background task {task_id} failed.&#34;)</p><p style="text-align: left;">    else:</p><p style="text-align: left;">        task_storage[task_id] = {&#34;status&#34;: &#34;SUCCESS&#34;, &#34;result&#34;: {&#34;result_data&#34;: result_or_error}}</p><p style="text-align: left;">        print(f&#34;Background task {task_id} succeeded.&#34;)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(f) backend/app/services.py (Refactored &#38; Expanded)</p><p style="text-align: left;"></p><p style="text-align: left;">import uuid</p><p style="text-align: left;">from fastapi import BackgroundTasks, HTTPException</p><p style="text-align: left;">from typing import Dict, Any</p><p style="text-align: left;">from . import tasks # Import the background task logic</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Task Submission Service Functions ---</p><p style="text-align: left;"></p><p style="text-align: left;">def start_simple_inference(model_id: str, payload: Dict[str, Any]) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;For tasks expected to be fast - direct synchronous call.&#34;&#34;&#34;</p><p style="text-align: left;">    # Example: Sentiment is often fast enough</p><p style="text-align: left;">    print(f&#34;Running simple inference for {model_id}&#34;)</p><p style="text-align: left;">    # Use the task helper directly but don&#39;t run in background</p><p style="text-align: left;">    result_or_error = tasks._make_hf_request(model_id, payload) </p><p style="text-align: left;">    if &#34;error&#34; in result_or_error:</p><p style="text-align: left;">         # Map error to HTTPException for consistent API response</p><p style="text-align: left;">         detail = result_or_error[&#39;error&#39;]</p><p style="text-align: left;">         status_code = 503 if &#34;loading&#34; in detail.lower() else 500</p><p style="text-align: left;">         raise HTTPException(status_code=status_code, detail=detail)</p><p style="text-align: left;">    return result_or_error</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">def start_background_task(</p><p style="text-align: left;">    background_tasks: BackgroundTasks,</p><p style="text-align: left;">    model_id: str,</p><p style="text-align: left;">    payload: Dict[str, Any],</p><p style="text-align: left;">    task_type: str # Helps the runner know how to handle response</p><p style="text-align: left;">) -&#62; str:</p><p style="text-align: left;">    &#34;&#34;&#34;Adds a task to FastAPI&#39;s BackgroundTasks.&#34;&#34;&#34;</p><p style="text-align: left;">    task_id = str(uuid.uuid4())</p><p style="text-align: left;">    # Add task to FastAPI&#39;s background runner</p><p style="text-align: left;">    background_tasks.add_task(tasks.run_inference_task, task_id, model_id, payload, task_type)</p><p style="text-align: left;">    # Initialize status in our (non-persistent) store immediately</p><p style="text-align: left;">    tasks.task_storage[task_id] = {&#34;status&#34;: &#34;ACCEPTED&#34;}</p><p style="text-align: left;">    print(f&#34;Task {task_id} accepted for background processing ({task_type} on {model_id})&#34;)</p><p style="text-align: left;">    return task_id</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">def get_task_status_info(task_id: str) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets status from the (non-persistent) task store.&#34;&#34;&#34;</p><p style="text-align: left;">    status_info = tasks.task_storage.get(task_id)</p><p style="text-align: left;">    if not status_info:</p><p style="text-align: left;">        # TODO: Check persistent storage (DB/Redis) if implemented</p><p style="text-align: left;">        raise HTTPException(status_code=404, detail=f&#34;Task ID &#39;{task_id}&#39; not found or expired.&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    # Return a copy including the task_id</p><p style="text-align: left;">    return {&#34;task_id&#34;: task_id, **status_info}</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Specific Task Starters ---</p><p style="text-align: left;"></p><p style="text-align: left;">def start_summarization(background_tasks: BackgroundTasks, text: str, min_len: int, max_len: int) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;min_length&#34;: min_len, &#34;max_length&#34;: max_len}}</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_SUMMARIZATION, payload, &#34;summarization&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_translation(background_tasks: BackgroundTasks, text: str, source_lang: Optional[str], target_lang: str) -&#62; str:</p><p style="text-align: left;">    # TODO: Add language detection logic if source_lang is None</p><p style="text-align: left;">    model_id = f&#34;{settings.MODEL_TRANSLATION_PREFIX}{source_lang or &#39;en&#39;}-{target_lang}&#34; # Default source if needed</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task(background_tasks, model_id, payload, &#34;translation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_image_generation(background_tasks: BackgroundTasks, prompt: str, negative_prompt: Optional[str]) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt}</p><p style="text-align: left;">    if negative_prompt:</p><p style="text-align: left;">        # Note: Parameter structure varies between image models! Check HF docs.</p><p style="text-align: left;">        payload[&#34;parameters&#34;] = {&#34;negative_prompt&#34;: negative_prompt} </p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_IMAGE_GEN, payload, &#34;image_generation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_doc_qa(background_tasks: BackgroundTasks, context: str, question: str) -&#62; str:</p><p style="text-align: left;">    # WARNING: Context size limits apply heavily here. Chunking needed for large docs.</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: {&#34;question&#34;: question, &#34;context&#34;: context}}</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_DOC_QA, payload, &#34;question_answering&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_transcription(background_tasks: BackgroundTasks, audio_bytes: bytes) -&#62; str:</p><p style="text-align: left;">    # HF API often takes raw bytes directly for audio</p><p style="text-align: left;">    # Need to adjust _make_hf_request to handle non-JSON payloads if necessary</p><p style="text-align: left;">    # Or potentially use a library that handles the upload format correctly.</p><p style="text-align: left;">    # This example assumes raw bytes payload works, which might need adjustment.</p><p style="text-align: left;">    # For now, we&#39;ll pass placeholder payload; REAL IMPLEMENTATION needed.</p><p style="text-align: left;">    print(&#34;WARNING: Transcription API call format needs verification. Passing raw bytes.&#34;)</p><p style="text-align: left;">    # This likely requires using the &#39;data&#39; parameter in requests, not &#39;json&#39;</p><p style="text-align: left;">    # return start_background_task(background_tasks, settings.MODEL_TRANSCRIPTION, audio_bytes, &#34;transcription&#34;) </p><p style="text-align: left;">    # --- Placeholder ---</p><p style="text-align: left;">    payload = {&#34;info&#34;: &#34;Placeholder for audio data handling&#34;} </p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_TRANSCRIPTION, payload, &#34;transcription&#34;)</p><p style="text-align: left;">    # --- End Placeholder ---</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">def start_tts(background_tasks: BackgroundTasks, text: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_TTS, payload, &#34;tts&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_code_generation(background_tasks: BackgroundTasks, prompt: str, language: str) -&#62; str:</p><p style="text-align: left;">    # Payload structure might vary based on model (e.g., needing parameters)</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt, &#34;parameters&#34;: {&#34;return_full_text&#34;: False}} # Example param</p><p style="text-align: left;">    # TODO: Potentially add language hints if model supports it</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_CODE_GEN, payload, &#34;code_generation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_zero_shot(background_tasks: BackgroundTasks, text: str, labels: List[str]) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;candidate_labels&#34;: labels}}</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_ZERO_SHOT, payload, &#34;zero_shot&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_ner(background_tasks: BackgroundTasks, text: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task(background_tasks, settings.MODEL_NER, payload, &#34;ner&#34;)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(g) backend/app/api.py (Refactored &#38; Expanded)</p><p style="text-align: left;"></p><p style="text-align: left;">from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends, UploadFile, File, Form</p><p style="text-align: left;">from typing import List, Optional</p><p style="text-align: left;">from . import models</p><p style="text-align: left;">from . import services</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"># TODO: Add authentication dependencies later</p><p style="text-align: left;"># from .auth import get_current_active_user</p><p style="text-align: left;"># from .models import User</p><p style="text-align: left;"></p><p style="text-align: left;">router = APIRouter()</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Helper Function for Parsing Task Results ---</p><p style="text-align: left;"># This needs refinement based on ACTUAL response structures from HF models</p><p style="text-align: left;">def _parse_task_result(task_data: dict) -&#62; Optional[models.TaskResult]:</p><p style="text-align: left;">    if task_data.get(&#34;status&#34;) == &#34;SUCCESS&#34; and &#34;result&#34; in task_data:</p><p style="text-align: left;">        raw_result = task_data[&#34;result&#34;].get(&#34;result_data&#34;) # Data is nested by run_inference_task</p><p style="text-align: left;">        # Add more specific parsing based on expected keys for each task type</p><p style="text-align: left;">        # This is a simplified example:</p><p style="text-align: left;">        if isinstance(raw_result, dict):</p><p style="text-align: left;">             # Check for common keys from our specific result models</p><p style="text-align: left;">             if &#34;summary_text&#34; in raw_result:</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.SummaryResult(**raw_result))</p><p style="text-align: left;">             elif &#34;translation_text&#34; in raw_result:</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.TranslationResult(**raw_result))</p><p style="text-align: left;">             elif &#34;image_base64&#34; in raw_result:</p><p style="text-align: left;">                  return models.TaskResult(result_data=models.ImageGenResult(**raw_result))</p><p style="text-align: left;">             elif &#34;entities&#34; in raw_result: # NER</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.NerResult(**raw_result))</p><p style="text-align: left;">             elif &#34;answer&#34; in raw_result: # QA</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.QAResult(**raw_result))</p><p style="text-align: left;">             elif &#34;labels&#34; in raw_result and &#34;scores&#34; in raw_result: # Zero-Shot</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.ZeroShotResult(**raw_result))</p><p style="text-align: left;">             elif &#34;generated_code&#34; in raw_result: # Code Gen</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.CodeGenResult(**raw_result))</p><p style="text-align: left;">             elif &#34;audio_base64&#34; in raw_result: # TTS</p><p style="text-align: left;">                  return models.TaskResult(result_data=models.TextToSpeechResult(**raw_result))</p><p style="text-align: left;">             elif &#34;transcription_text&#34; in raw_result: # Transcription (assuming key)</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.TranscriptionResult(**raw_result))</p><p style="text-align: left;">             # Add more specific checks as needed</p><p style="text-align: left;">             else:</p><p style="text-align: left;">                  return models.TaskResult(result_data=raw_result) # Return raw dict if unknown</p><p style="text-align: left;">        elif raw_result is not None:</p><p style="text-align: left;">             # Handle cases where result is not a dict (e.g., simple string)</p><p style="text-align: left;">             return models.TaskResult(result_data=raw_result) </p><p style="text-align: left;">    return None # No result if status isn&#39;t SUCCESS</p><p style="text-align: left;"></p><p style="text-align: left;"># --- API Endpoints ---</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/sentiment&#34;, response_model=models.SentimentResult, responses={500: {&#34;model&#34;: models.ErrorResponse}, 503: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def analyze_sentiment(data: models.TextInput): # Synchronous example</p><p style="text-align: left;">    &#34;&#34;&#34;Analyzes sentiment using a suitable HF model.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Note: Sentiment models often return a list of lists, parse accordingly</p><p style="text-align: left;">        result = services.start_simple_inference(settings.MODEL_SENTIMENT, {&#34;inputs&#34;: data.text})</p><p style="text-align: left;">        # More robust parsing</p><p style="text-align: left;">        if result and isinstance(result, list) and result[0] and isinstance(result[0], list):</p><p style="text-align: left;">            # Map raw scores to our defined model</p><p style="text-align: left;">            scores = [models.SentimentScore(**item) for item in result[0]]</p><p style="text-align: left;">            return models.SentimentResult(sentiment=scores)</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            print(f&#34;Unexpected sentiment response format: {result}&#34;)</p><p style="text-align: left;">            raise HTTPException(status_code=500, detail=&#34;Could not parse sentiment response from HF API&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error in sentiment endpoint: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Internal server error: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/summarize&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def summarize_text(data: models.SummarizationRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text summarization.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_summarization(background_tasks, data.text, data.min_length, data.max_length)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting summarization task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Failed to start summarization task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/translate&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def translate_text(data: models.TranslationRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for translation.&#34;&#34;&#34;</p><p style="text-align: left;">    # Basic language code validation (add more robust checks)</p><p style="text-align: left;">    if not data.target_lang or len(data.target_lang) &#60; 2:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Invalid target language code.&#34;)</p><p style="text-align: left;">    # TODO: Add source language validation/detection if needed</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_translation(background_tasks, data.text, data.source_lang, data.target_lang)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting translation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start translation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-image&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_image(data: models.ImageGenRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for image generation.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Prompt cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_image_generation(background_tasks, data.prompt, data.negative_prompt)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting image generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start image generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/qa-document&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def qa_document(data: models.DocQARequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Document Question Answering.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.context or not data.question:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Context and question cannot be empty.&#34;)</p><p style="text-align: left;">    # TODO: Add context length check/warning/chunking</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_doc_qa(background_tasks, data.context, data.question)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting QA task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start QA task: {e}&#34;)</p><p style="text-align: left;">        </p><p style="text-align: left;">@router.post(&#34;/api/transcribe&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def transcribe_audio(background_tasks: BackgroundTasks, file: UploadFile = File(...)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for audio transcription (accepts file upload).&#34;&#34;&#34;</p><p style="text-align: left;">    # TODO: Add robust file type/size validation</p><p style="text-align: left;">    if not file.content_type.startswith(&#34;audio/&#34;):</p><p style="text-align: left;">         raise HTTPException(status_code=400, detail=&#34;Invalid file type. Please upload an audio file.&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Read file bytes - careful with large files, consider streaming/chunking for production</p><p style="text-align: left;">        audio_bytes = await file.read()</p><p style="text-align: left;">        if not audio_bytes:</p><p style="text-align: left;">             raise HTTPException(status_code=400, detail=&#34;Uploaded file is empty.&#34;)</p><p style="text-align: left;">        </p><p style="text-align: left;">        # WARNING: HF API expects raw bytes, but &#39;requests&#39; JSON payload needs serializable data.</p><p style="text-align: left;">        # How raw bytes are sent depends heavily on the specific API/model endpoint.</p><p style="text-align: left;">        # For Whisper API via libraries/endpoints, often you pass the bytes directly.</p><p style="text-align: left;">        # The simple BackgroundTask here using &#39;requests&#39; might need adjustment</p><p style="text-align: left;">        # to send &#39;data=audio_bytes&#39; instead of &#39;json=payload&#39;.</p><p style="text-align: left;">        # For now, calling the placeholder service function.</p><p style="text-align: left;">        print(&#34;INFO: Passing raw audio bytes to placeholder background task starter.&#34;)</p><p style="text-align: left;">        task_id = services.start_transcription(background_tasks, audio_bytes)</p><p style="text-align: left;">        </p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting transcription task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to process file or start transcription task: {e}&#34;)</p><p style="text-align: left;">    finally:</p><p style="text-align: left;">        await file.close()</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/text-to-speech&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def text_to_speech(data: models.TextToSpeechRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text-to-speech synthesis.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_tts(background_tasks, data.text)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting TTS task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start TTS task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-code&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_code(data: models.CodeGenRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for code generation.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt or not data.language:</p><p style="text-align: left;">        raise HTTPException(status_code=422, detail=&#34;Prompt and language are required.&#34;)</p><p style="text-align: left;">    # TODO: Validate language if model expects specific ones</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_code_generation(background_tasks, data.prompt, data.language)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting code generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start code generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/classify-zero-shot&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def classify_zero_shot(data: models.ZeroShotRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for zero-shot text classification.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text or not data.candidate_labels:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text and candidate labels are required.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_zero_shot(background_tasks, data.text, data.candidate_labels)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting zero-shot classification task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Failed to start zero-shot classification task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/extract-entities&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def extract_entities(data: models.NerRequest, background_tasks: BackgroundTasks):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Named Entity Recognition.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_ner(background_tasks, data.text)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting NER task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start NER task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Central Task Status Endpoint ---</p><p style="text-align: left;">@router.get(&#34;/api/task-status/{task_id}&#34;, response_model=models.TaskStatusResponse, responses={404: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def get_task_status_endpoint(task_id: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Polls for the status and result of any background task.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        status_data = services.get_task_status_info(task_id)</p><p style="text-align: left;">        # Try to parse the specific result based on common keys/structures</p><p style="text-align: left;">        parsed_result = _parse_task_result(status_data)</p><p style="text-align: left;">        # Include parsed result if available, otherwise keep raw if needed (or omit)</p><p style="text-align: left;">        response_payload = {**status_data, &#34;result&#34;: parsed_result} </p><p style="text-align: left;">        return models.TaskStatusResponse(**response_payload)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e # Propagate 404 correctly</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error getting task status for {task_id}: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Internal server error retrieving task status: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add endpoints for User Authentication (Register, Login, Get Me)</p><p style="text-align: left;"># TODO: Add endpoints for saving/retrieving results from DB (e.g., /api/results, POST /api/results/{task_id}/save)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(h) backend/app/main.py (Slightly updated imports)</p><p style="text-align: left;"></p><p style="text-align: left;">from fastapi import FastAPI</p><p style="text-align: left;">from fastapi.middleware.cors import CORSMiddleware</p><p style="text-align: left;">from . import api # Import the API router</p><p style="text-align: left;">from .config import settings # Import settings to ensure env vars are checked early</p><p style="text-align: left;"></p><p style="text-align: left;">app = FastAPI(</p><p style="text-align: left;">    title=&#34;NeuralBlitz Multi-Tool AI - v0.1 Expanded&#34;,</p><p style="text-align: left;">    description=&#34;Backend API for various Hugging Face model integrations.&#34;,</p><p style="text-align: left;">    version=&#34;0.1.0&#34;</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Configure CORS</p><p style="text-align: left;"># TODO: Restrict origins in production!</p><p style="text-align: left;">origins = [</p><p style="text-align: left;">    &#34;http://localhost:3000&#34;,</p><p style="text-align: left;">    &#34;http://127.0.0.1:3000&#34;,</p><p style="text-align: left;">    # Add your deployed frontend URL here later</p><p style="text-align: left;">]</p><p style="text-align: left;"></p><p style="text-align: left;">app.add_middleware(</p><p style="text-align: left;">    CORSMiddleware,</p><p style="text-align: left;">    allow_origins=origins,</p><p style="text-align: left;">    allow_credentials=True,</p><p style="text-align: left;">    allow_methods=[&#34;*&#34;],</p><p style="text-align: left;">    allow_headers=[&#34;*&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Include the API router</p><p style="text-align: left;">app.include_router(api.router)</p><p style="text-align: left;"></p><p style="text-align: left;">@app.get(&#34;/&#34;)</p><p style="text-align: left;">async def read_root():</p><p style="text-align: left;">    # Basic check if token seems configured</p><p style="text-align: left;">    token_status = &#34;SET&#34; if settings.HF_API_TOKEN and settings.HF_API_TOKEN != &#34;YOUR_TOKEN_HERE&#34; else &#34;MISSING/INVALID&#34;</p><p style="text-align: left;">    return {</p><p style="text-align: left;">        &#34;message&#34;: &#34;Welcome to the NeuralBlitz AI Backend!&#34;,</p><p style="text-align: left;">        &#34;status&#34;: &#34;Operational&#34;,</p><p style="text-align: left;">        &#34;huggingface_token_status&#34;: token_status</p><p style="text-align: left;">        }</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add database startup/shutdown events later</p><p style="text-align: left;"># from .database import engine, SQLModel # Example</p><p style="text-align: left;"># @app.on_event(&#34;startup&#34;)</p><p style="text-align: left;"># async def on_startup():</p><p style="text-align: left;">#     async with engine.begin() as conn:</p><p style="text-align: left;">#         await conn.run_sync(SQLModel.metadata.create_all)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">3. Frontend Code (Expanded - React Skeleton)</p><p style="text-align: left;"></p><p style="text-align: left;">(a) Install React Router:</p><p style="text-align: left;">Navigate to frontend/ and run: npm install react-router-dom</p><p style="text-align: left;"></p><p style="text-align: left;">(b) frontend/src/App.js (Using Router)</p><p style="text-align: left;"></p><p style="text-align: left;">import React from &#39;react&#39;;</p><p style="text-align: left;">import { BrowserRouter as Router, Routes, Route, Link } from &#39;react-router-dom&#39;;</p><p style="text-align: left;">import &#39;./App.css&#39;;</p><p style="text-align: left;">import SentimentAnalyzer from &#39;./components/SentimentAnalyzer&#39;;</p><p style="text-align: left;">import ImageGenerator from &#39;./components/ImageGenerator&#39;;</p><p style="text-align: left;">import Summarizer from &#39;./components/Summarizer&#39;; // Create this</p><p style="text-align: left;">import Translator from &#39;./components/Translator&#39;; // Create this</p><p style="text-align: left;">import DocQA from &#39;./components/DocQA&#39;;           // Create this</p><p style="text-align: left;">import Transcriber from &#39;./components/Transcriber&#39;;   // Create this</p><p style="text-align: left;">import TTSPlayer from &#39;./components/TTSPlayer&#39;;     // Create this</p><p style="text-align: left;">import CodeGen from &#39;./components/CodeGen&#39;;         // Create this</p><p style="text-align: left;">import ZeroShotClassifier from &#39;./components/ZeroShotClassifier&#39;; // Create this</p><p style="text-align: left;">import NERExtractor from &#39;./components/NERExtractor&#39;; // Create this</p><p style="text-align: left;">// TODO: Import Login, Register, History components later</p><p style="text-align: left;"></p><p style="text-align: left;">function NavBar() {</p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;nav className=&#34;navbar&#34;&#62;</p><p style="text-align: left;">      &#60;Link to=&#34;/&#34;&#62;Sentiment&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/summarize&#34;&#62;Summarize&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/translate&#34;&#62;Translate&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/image-gen&#34;&#62;Image Gen&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/doc-qa&#34;&#62;Doc Q&#38;A&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/transcribe&#34;&#62;Transcribe&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/tts&#34;&#62;TTS&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/code-gen&#34;&#62;Code Gen&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/zero-shot&#34;&#62;Zero-Shot&#60;/Link&#62; |</p><p style="text-align: left;">      &#60;Link to=&#34;/ner&#34;&#62;NER&#60;/Link&#62;</p><p style="text-align: left;">      {/* TODO: Add Links for History, Login/Logout */}</p><p style="text-align: left;">    &#60;/nav&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">function App() {</p><p style="text-align: left;">  // TODO: Add auth context provider here later</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;Router&#62;</p><p style="text-align: left;">      &#60;div className=&#34;App&#34;&#62;</p><p style="text-align: left;">        &#60;header className=&#34;App-header&#34;&#62;</p><p style="text-align: left;">          &#60;h1&#62;NeuralBlitz AI Tools v0.1&#60;/h1&#62;</p><p style="text-align: left;">          &#60;NavBar /&#62;</p><p style="text-align: left;">        &#60;/header&#62;</p><p style="text-align: left;">        &#60;main&#62;</p><p style="text-align: left;">          &#60;Routes&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/&#34; element={&#60;SentimentAnalyzer /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/summarize&#34; element={&#60;Summarizer /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/translate&#34; element={&#60;Translator /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/image-gen&#34; element={&#60;ImageGenerator /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/doc-qa&#34; element={&#60;DocQA /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/transcribe&#34; element={&#60;Transcriber /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/tts&#34; element={&#60;TTSPlayer /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/code-gen&#34; element={&#60;CodeGen /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/zero-shot&#34; element={&#60;ZeroShotClassifier /&#62;} /&#62;</p><p style="text-align: left;">            &#60;Route path=&#34;/ner&#34; element={&#60;NERExtractor /&#62;} /&#62;</p><p style="text-align: left;">            {/* TODO: Add routes for Login, Register, History, Protected Routes */}</p><p style="text-align: left;">          &#60;/Routes&#62;</p><p style="text-align: left;">        &#60;/main&#62;</p><p style="text-align: left;">        &#60;footer className=&#34;App-footer&#34;&#62;</p><p style="text-align: left;">          &#60;p&#62;NeuralBlitz Demo&#60;/p&#62;</p><p style="text-align: left;">        &#60;/footer&#62;</p><p style="text-align: left;">      &#60;/div&#62;</p><p style="text-align: left;">    &#60;/Router&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default App;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(c) frontend/src/services/apiService.js (NEW)</p><p style="text-align: left;"></p><p style="text-align: left;">import axios from &#39;axios&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">// Use environment variable or default for development</p><p style="text-align: left;">const API_BASE_URL = process.env.REACT_APP_API_URL || &#39;http://localhost:8000&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">// Create an axios instance</p><p style="text-align: left;">const apiClient = axios.create({</p><p style="text-align: left;">  baseURL: API_BASE_URL,</p><p style="text-align: left;">  headers: {</p><p style="text-align: left;">    &#39;Content-Type&#39;: &#39;application/json&#39;,</p><p style="text-align: left;">  },</p><p style="text-align: left;">});</p><p style="text-align: left;"></p><p style="text-align: left;">// TODO: Add interceptor to include JWT token from auth state/local storage</p><p style="text-align: left;">// apiClient.interceptors.request.use(config =&#62; {</p><p style="text-align: left;">//   const token = getAuthToken(); // Implement getAuthToken()</p><p style="text-align: left;">//   if (token) {</p><p style="text-align: left;">//     config.headers.Authorization = `Bearer ${token}`;</p><p style="text-align: left;">//   }</p><p style="text-align: left;">//   return config;</p><p style="text-align: left;">// });</p><p style="text-align: left;"></p><p style="text-align: left;">// --- API Call Functions ---</p><p style="text-align: left;"></p><p style="text-align: left;">export const analyzeSentiment = async (text) =&#62; {</p><p style="text-align: left;">  try {</p><p style="text-align: left;">    const response = await apiClient.post(&#39;/api/sentiment&#39;, { text });</p><p style="text-align: left;">    return response.data; // { sentiment: [{ label: &#39;POSITIVE&#39;, score: 0.99 }] }</p><p style="text-align: left;">  } catch (error) {</p><p style="text-align: left;">    console.error(&#34;API Error (Sentiment):&#34;, error.response?.data || error.message);</p><p style="text-align: left;">    throw error.response?.data || new Error(&#34;Sentiment analysis failed&#34;);</p><p style="text-align: left;">  }</p><p style="text-align: left;">};</p><p style="text-align: left;"></p><p style="text-align: left;">// --- Functions for tasks returning Task ID ---</p><p style="text-align: left;"></p><p style="text-align: left;">const startBackgroundTask = async (endpoint, payload) =&#62; {</p><p style="text-align: left;">   try {</p><p style="text-align: left;">    const response = await apiClient.post(endpoint, payload);</p><p style="text-align: left;">    return response.data; // { task_id: &#34;...&#34;, status: &#34;ACCEPTED&#34;, message: &#34;...&#34; }</p><p style="text-align: left;">  } catch (error) {</p><p style="text-align: left;">    console.error(`API Error (${endpoint}):`, error.response?.data || error.message);</p><p style="text-align: left;">    throw error.response?.data || new Error(`Failed to start task at ${endpoint}`);</p><p style="text-align: left;">  }</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startSummarization = async (text, minLength, maxLength) =&#62; {</p><p style="text-align: left;">    return startBackgroundTask(&#39;/api/summarize&#39;, { text, min_length: minLength, max_length: maxLength });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startTranslation = async (text, targetLang, sourceLang = null) =&#62; {</p><p style="text-align: left;">    const payload = { text, target_lang: targetLang };</p><p style="text-align: left;">    if (sourceLang) payload.source_lang = sourceLang;</p><p style="text-align: left;">    return startBackgroundTask(&#39;/api/translate&#39;, payload);</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startImageGeneration = async (prompt, negativePrompt = null) =&#62; {</p><p style="text-align: left;">    const payload = { prompt };</p><p style="text-align: left;">    if (negativePrompt) payload.negative_prompt = negativePrompt;</p><p style="text-align: left;">    return startBackgroundTask(&#39;/api/generate-image&#39;, payload);</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startDocQA = async (context, question) =&#62; {</p><p style="text-align: left;">     return startBackgroundTask(&#39;/api/qa-document&#39;, { context, question });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startTranscription = async (audioFile) =&#62; {</p><p style="text-align: left;">    // Sending files requires FormData</p><p style="text-align: left;">    const formData = new FormData();</p><p style="text-align: left;">    formData.append(&#34;file&#34;, audioFile); </p><p style="text-align: left;">    try {</p><p style="text-align: left;">        // Use axios directly for multipart/form-data</p><p style="text-align: left;">        const response = await axios.post(`${API_BASE_URL}/api/transcribe`, formData, {</p><p style="text-align: left;">             headers: {</p><p style="text-align: left;">                 &#39;Content-Type&#39;: &#39;multipart/form-data&#39;,</p><p style="text-align: left;">                 // TODO: Add Authorization header if needed separately for axios instance</p><p style="text-align: left;">             }</p><p style="text-align: left;">        });</p><p style="text-align: left;">        return response.data; // TaskResponse</p><p style="text-align: left;">    } catch (error) {</p><p style="text-align: left;">        console.error(`API Error (/api/transcribe):`, error.response?.data || error.message);</p><p style="text-align: left;">        throw error.response?.data || new Error(`Failed to start transcription task`);</p><p style="text-align: left;">    }</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startTextToSpeech = async (text) =&#62; {</p><p style="text-align: left;">     return startBackgroundTask(&#39;/api/text-to-speech&#39;, { text });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startCodeGen = async (prompt, language) =&#62; {</p><p style="text-align: left;">     return startBackgroundTask(&#39;/api/generate-code&#39;, { prompt, language });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startZeroShotClassification = async (text, candidateLabels) =&#62; {</p><p style="text-align: left;">    return startBackgroundTask(&#39;/api/classify-zero-shot&#39;, { text, candidate_labels: candidateLabels });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export const startNerExtraction = async (text) =&#62; {</p><p style="text-align: left;">    return startBackgroundTask(&#39;/api/extract-entities&#39;, { text });</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">// --- Function for polling task status ---</p><p style="text-align: left;"></p><p style="text-align: left;">export const getTaskStatus = async (taskId) =&#62; {</p><p style="text-align: left;">  if (!taskId) throw new Error(&#34;Task ID is required for polling.&#34;);</p><p style="text-align: left;">  try {</p><p style="text-align: left;">    const response = await apiClient.get(`/api/task-status/${taskId}`);</p><p style="text-align: left;">    return response.data; // TaskStatusResponse { task_id, status, result?, error? }</p><p style="text-align: left;">  } catch (error) {</p><p style="text-align: left;">    console.error(`API Error (Task Status ${taskId}):`, error.response?.data || error.message);</p><p style="text-align: left;">     // Don&#39;t throw generic error if 404, let component handle &#39;not found&#39;</p><p style="text-align: left;">     if (error.response?.status === 404) {</p><p style="text-align: left;">         return { task_id: taskId, status: &#34;NOT_FOUND&#34;, error: &#34;Task ID not found or expired.&#34;};</p><p style="text-align: left;">     }</p><p style="text-align: left;">    throw error.response?.data || new Error(&#34;Failed to get task status&#34;);</p><p style="text-align: left;">  }</p><p style="text-align: left;">};</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">// TODO: Add functions for Login, Register, Get History, Save Result etc.</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(d) frontend/src/components/SentimentAnalyzer.js (Updated to use apiService)</p><p style="text-align: left;"></p><p style="text-align: left;">import React, { useState } from &#39;react&#39;;</p><p style="text-align: left;">import &#39;./Components.css&#39;;</p><p style="text-align: left;">import { analyzeSentiment } from &#39;../services/apiService&#39;; // Import the service</p><p style="text-align: left;"></p><p style="text-align: left;">function SentimentAnalyzer() {</p><p style="text-align: left;">  const [inputText, setInputText] = useState(&#39;&#39;);</p><p style="text-align: left;">  const [result, setResult] = useState(null);</p><p style="text-align: left;">  const [isLoading, setIsLoading] = useState(false);</p><p style="text-align: left;">  const [error, setError] = useState(null);</p><p style="text-align: left;"></p><p style="text-align: left;">  const handleSubmit = async (event) =&#62; {</p><p style="text-align: left;">    event.preventDefault();</p><p style="text-align: left;">    setIsLoading(true);</p><p style="text-align: left;">    setError(null);</p><p style="text-align: left;">    setResult(null);</p><p style="text-align: left;"></p><p style="text-align: left;">    try {</p><p style="text-align: left;">       // Use the imported service function</p><p style="text-align: left;">      const data = await analyzeSentiment(inputText); </p><p style="text-align: left;">      // Assuming the backend now returns SentimentResult model directly</p><p style="text-align: left;">      setResult(data); </p><p style="text-align: left;"></p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      // Error object might have more detail now</p><p style="text-align: left;">      setError(err.detail || err.message || &#39;Sentiment analysis failed.&#39;);</p><p style="text-align: left;">      console.error(&#34;Sentiment analysis error:&#34;, err);</p><p style="text-align: left;">    } finally {</p><p style="text-align: left;">      setIsLoading(false);</p><p style="text-align: left;">    }</p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  // Helper to display sentiment scores</p><p style="text-align: left;">  const renderSentimentScores = (scores) =&#62; {</p><p style="text-align: left;">     if (!scores || scores.length === 0) return &#60;p&#62;No sentiment data.&#60;/p&#62;;</p><p style="text-align: left;">     // Find the highest score (often the primary sentiment)</p><p style="text-align: left;">     const primarySentiment = scores.reduce((max, current) =&#62; (current.score &#62; max.score ? current : max), scores[0]);</p><p style="text-align: left;">     return (</p><p style="text-align: left;">        &#60;&#62;</p><p style="text-align: left;">         &#60;p&#62;Primary Label: &#60;span className={`sentiment-${primarySentiment.label?.toLowerCase()}`}&#62;{primarySentiment.label}&#60;/span&#62;&#60;/p&#62;</p><p style="text-align: left;">         &#60;p&#62;Score: {primarySentiment.score?.toFixed(3)}&#60;/p&#62;</p><p style="text-align: left;">         {/* Optionally display all scores if model returns multiple */}</p><p style="text-align: left;">         {/* </p><p style="text-align: left;">         &#60;h4&#62;All Scores:&#60;/h4&#62;</p><p style="text-align: left;">         &#60;ul&#62;</p><p style="text-align: left;">           {scores.map((s, index) =&#62; &#60;li key={index}&#62;{s.label}: {s.score.toFixed(3)}&#60;/li&#62;)}</p><p style="text-align: left;">         &#60;/ul&#62; </p><p style="text-align: left;">         */}</p><p style="text-align: left;">        &#60;/&#62;</p><p style="text-align: left;">     )</p><p style="text-align: left;">  }</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;div className=&#34;ai-tool&#34;&#62;</p><p style="text-align: left;">      &#60;h2&#62;Sentiment Analysis&#60;/h2&#62;</p><p style="text-align: left;">      &#60;form onSubmit={handleSubmit}&#62;</p><p style="text-align: left;">        &#60;textarea</p><p style="text-align: left;">          value={inputText}</p><p style="text-align: left;">          onChange={(e) =&#62; setInputText(e.target.value)}</p><p style="text-align: left;">          rows=&#34;5&#34;</p><p style="text-align: left;">          placeholder=&#34;Enter text to analyze...&#34;</p><p style="text-align: left;">          required</p><p style="text-align: left;">        /&#62;</p><p style="text-align: left;">        &#60;br /&#62;</p><p style="text-align: left;">        &#60;button type=&#34;submit&#34; disabled={isLoading}&#62;</p><p style="text-align: left;">          {isLoading ? &#39;Analyzing...&#39; : &#39;Analyze Sentiment&#39;}</p><p style="text-align: left;">        &#60;/button&#62;</p><p style="text-align: left;">      &#60;/form&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">      {isLoading &#38;&#38; &#60;p&#62;Loading...&#60;/p&#62;}</p><p style="text-align: left;">      {error &#38;&#38; &#60;p className=&#34;error&#34;&#62;Error: {error}&#60;/p&#62;}</p><p style="text-align: left;">      {result &#38;&#38; result.sentiment &#38;&#38; ( // Check if result and sentiment array exist</p><p style="text-align: left;">        &#60;div className=&#34;result&#34;&#62;</p><p style="text-align: left;">          &#60;h3&#62;Result:&#60;/h3&#62;</p><p style="text-align: left;">          {renderSentimentScores(result.sentiment)}</p><p style="text-align: left;">        &#60;/div&#62;</p><p style="text-align: left;">      )}</p><p style="text-align: left;">    &#60;/div&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default SentimentAnalyzer;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(e) frontend/src/components/ImageGenerator.js (Updated to use apiService &#38; polling helper)</p><p style="text-align: left;"></p><p style="text-align: left;">import React, { useState } from &#39;react&#39;;</p><p style="text-align: left;">import &#39;./Components.css&#39;;</p><p style="text-align: left;">import { startImageGeneration, getTaskStatus } from &#39;../services/apiService&#39;; // Import services</p><p style="text-align: left;">import useTaskPolling from &#39;../hooks/useTaskPolling&#39;; // Import the custom hook (create next)</p><p style="text-align: left;"></p><p style="text-align: left;">function ImageGenerator() {</p><p style="text-align: left;">  const [prompt, setPrompt] = useState(&#39;&#39;);</p><p style="text-align: left;">  const [negativePrompt, setNegativePrompt] = useState(&#39;&#39;);</p><p style="text-align: left;">  </p><p style="text-align: left;">  // Use the custom hook for polling logic</p><p style="text-align: left;">  const { taskId, status, result, error, startTask } = useTaskPolling(getTaskStatus);</p><p style="text-align: left;"></p><p style="text-align: left;">  const handleSubmit = async (event) =&#62; {</p><p style="text-align: left;">    event.preventDefault();</p><p style="text-align: left;">    // Let the hook handle status updates etc.</p><p style="text-align: left;">    startTask(() =&#62; startImageGeneration(prompt, negativePrompt)); </p><p style="text-align: left;">  };</p><p style="text-align: left;"></p><p style="text-align: left;">  // Extract image data from the generic result object managed by the hook</p><p style="text-align: left;">  const imageData = status === &#39;SUCCESS&#39; ? result?.result_data : null;</p><p style="text-align: left;">  const imageBase64 = imageData?.image_base64;</p><p style="text-align: left;"></p><p style="text-align: left;">  return (</p><p style="text-align: left;">    &#60;div className=&#34;ai-tool&#34;&#62;</p><p style="text-align: left;">      &#60;h2&#62;Text-to-Image Generator&#60;/h2&#62;</p><p style="text-align: left;">      &#60;form onSubmit={handleSubmit}&#62;</p><p style="text-align: left;">        &#60;label htmlFor=&#34;prompt&#34;&#62;Prompt:&#60;/label&#62;&#60;br/&#62;</p><p style="text-align: left;">        &#60;textarea</p><p style="text-align: left;">          id=&#34;prompt&#34;</p><p style="text-align: left;">          value={prompt}</p><p style="text-align: left;">          onChange={(e) =&#62; setPrompt(e.target.value)}</p><p style="text-align: left;">          rows=&#34;3&#34;</p><p style="text-align: left;">          placeholder=&#34;Describe the image...&#34;</p><p style="text-align: left;">          required</p><p style="text-align: left;">        /&#62;&#60;br/&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">        &#60;label htmlFor=&#34;neg-prompt&#34;&#62;Negative Prompt (Optional):&#60;/label&#62;&#60;br/&#62;</p><p style="text-align: left;">        &#60;input</p><p style="text-align: left;">          id=&#34;neg-prompt&#34;</p><p style="text-align: left;">          type=&#34;text&#34;</p><p style="text-align: left;">          value={negativePrompt}</p><p style="text-align: left;">          onChange={(e) =&#62; setNegativePrompt(e.target.value)}</p><p style="text-align: left;">          placeholder=&#34;Things to avoid...&#34;</p><p style="text-align: left;">        /&#62;&#60;br/&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">        &#60;button type=&#34;submit&#34; disabled={status === &#39;PENDING&#39; || status === &#39;ACCEPTED&#39;}&#62;</p><p style="text-align: left;">          {status === &#39;PENDING&#39; || status === &#39;ACCEPTED&#39; ? &#39;Generating...&#39; : &#39;Generate Image&#39;}</p><p style="text-align: left;">        &#60;/button&#62;</p><p style="text-align: left;">      &#60;/form&#62;</p><p style="text-align: left;"></p><p style="text-align: left;">      {(status === &#39;PENDING&#39; || status === &#39;ACCEPTED&#39;) &#38;&#38; taskId &#38;&#38; </p><p style="text-align: left;">        &#60;p&#62;Generating image (Task ID: {taskId}). Status will update...&#60;/p&#62;}</p><p style="text-align: left;">      {status === &#39;FAILURE&#39; &#38;&#38; &#60;p className=&#34;error&#34;&#62;Error: {error || &#39;Image generation failed.&#39;}&#60;/p&#62;}</p><p style="text-align: left;">      </p><p style="text-align: left;">      {status === &#39;SUCCESS&#39; &#38;&#38; imageBase64 &#38;&#38; (</p><p style="text-align: left;">        &#60;div className=&#34;result&#34;&#62;</p><p style="text-align: left;">          &#60;h3&#62;Generated Image:&#60;/h3&#62;</p><p style="text-align: left;">          &#60;img src={`data:image/jpeg;base64,${imageBase64}`} alt={prompt} /&#62;</p><p style="text-align: left;">        &#60;/div&#62;</p><p style="text-align: left;">      )}</p><p style="text-align: left;">      {status === &#39;SUCCESS&#39; &#38;&#38; !imageBase64 &#38;&#38; &#60;p className=&#34;error&#34;&#62;Generation succeeded but no image data received.&#60;/p&#62;}</p><p style="text-align: left;">    &#60;/div&#62;</p><p style="text-align: left;">  );</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default ImageGenerator;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(f) frontend/src/hooks/useTaskPolling.js (NEW Custom Hook)</p><p style="text-align: left;"></p><p style="text-align: left;">import { useState, useEffect, useRef, useCallback } from &#39;react&#39;;</p><p style="text-align: left;"></p><p style="text-align: left;">// Custom Hook for polling background task status</p><p style="text-align: left;">function useTaskPolling(getStatusFunction, pollInterval = 3000) {</p><p style="text-align: left;">  const [taskId, setTaskId] = useState(null);</p><p style="text-align: left;">  const [status, setStatus] = useState(&#39;IDLE&#39;); // IDLE, ACCEPTED, PENDING, SUCCESS, FAILURE, NOT_FOUND</p><p style="text-align: left;">  const [result, setResult] = useState(null);</p><p style="text-align: left;">  const [error, setError] = useState(null);</p><p style="text-align: left;">  const intervalRef = useRef(null);</p><p style="text-align: left;"></p><p style="text-align: left;">  // Function to stop polling explicitly</p><p style="text-align: left;">  const stopPolling = useCallback(() =&#62; {</p><p style="text-align: left;">    if (intervalRef.current) {</p><p style="text-align: left;">      clearInterval(intervalRef.current);</p><p style="text-align: left;">      intervalRef.current = null;</p><p style="text-align: left;">      // console.log(&#34;Polling stopped for task:&#34;, taskId); // Optional logging</p><p style="text-align: left;">    }</p><p style="text-align: left;">  }, []); // No dependencies, it only uses the ref</p><p style="text-align: left;"></p><p style="text-align: left;">  // Function to poll status</p><p style="text-align: left;">  const pollStatus = useCallback(async (currentTaskId) =&#62; {</p><p style="text-align: left;">    if (!currentTaskId) {</p><p style="text-align: left;">        stopPolling();</p><p style="text-align: left;">        return;</p><p style="text-align: left;">    }</p><p style="text-align: left;">    // console.log(&#34;Polling status for task:&#34;, currentTaskId); // Optional logging</p><p style="text-align: left;">    try {</p><p style="text-align: left;">      const data = await getStatusFunction(currentTaskId); // Use the passed function</p><p style="text-align: left;">      setStatus(data.status);</p><p style="text-align: left;"></p><p style="text-align: left;">      if (data.status === &#39;SUCCESS&#39;) {</p><p style="text-align: left;">        setResult(data.result || null); // Store the entire result object</p><p style="text-align: left;">        setError(null);</p><p style="text-align: left;">        setTaskId(null); // Clear task ID only on final success/failure</p><p style="text-align: left;">        stopPolling();</p><p style="text-align: left;">      } else if (data.status === &#39;FAILURE&#39;) {</p><p style="text-align: left;">        setError(data.error || &#39;Task failed for an unknown reason.&#39;);</p><p style="text-align: left;">        setResult(null);</p><p style="text-align: left;">        setTaskId(null); // Clear task ID only on final success/failure</p><p style="text-align: left;">        stopPolling();</p><p style="text-align: left;">      } else if (data.status === &#39;NOT_FOUND&#39;) {</p><p style="text-align: left;">         setError(data.error || &#39;Task not found.&#39;);</p><p style="text-align: left;">         setResult(null);</p><p style="text-align: left;">         setTaskId(null);</p><p style="text-align: left;">         stopPolling();</p><p style="text-align: left;">      }</p><p style="text-align: left;">      // If PENDING or ACCEPTED, polling continues</p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      console.error(&#34;Polling error:&#34;, err);</p><p style="text-align: left;">      setError(err.detail || err.message || &#39;Failed to get task status.&#39;);</p><p style="text-align: left;">      setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">      setTaskId(null); // Clear task ID on error</p><p style="text-align: left;">      stopPolling();</p><p style="text-align: left;">    }</p><p style="text-align: left;">  }, [getStatusFunction, stopPolling]); // Include getStatusFunction dependency</p><p style="text-align: left;"></p><p style="text-align: left;">  // Effect to manage the polling interval</p><p style="text-align: left;">  useEffect(() =&#62; {</p><p style="text-align: left;">    if (taskId &#38;&#38; (status === &#39;PENDING&#39; || status === &#39;ACCEPTED&#39;)) {</p><p style="text-align: left;">      // Clear existing interval if any (safety check)</p><p style="text-align: left;">      stopPolling();</p><p style="text-align: left;">      // Start new interval</p><p style="text-align: left;">      intervalRef.current = setInterval(() =&#62; {</p><p style="text-align: left;">        pollStatus(taskId);</p><p style="text-align: left;">      }, pollInterval);</p><p style="text-align: left;">      // console.log(&#34;Polling started for task:&#34;, taskId); // Optional logging</p><p style="text-align: left;">    } else {</p><p style="text-align: left;">        // Stop polling if task ID is cleared or status is final</p><p style="text-align: left;">       stopPolling();</p><p style="text-align: left;">    }</p><p style="text-align: left;"></p><p style="text-align: left;">    // Cleanup function to clear interval on unmount or when dependencies change</p><p style="text-align: left;">    return () =&#62; stopPolling();</p><p style="text-align: left;">  }, [taskId, status, pollInterval, pollStatus, stopPolling]); // Add dependencies</p><p style="text-align: left;"></p><p style="text-align: left;">  // Function for components to start a task</p><p style="text-align: left;">  const startTask = useCallback(async (taskStartFunction) =&#62; {</p><p style="text-align: left;">    // Reset state before starting</p><p style="text-align: left;">    stopPolling(); // Stop any previous polling</p><p style="text-align: left;">    setTaskId(null);</p><p style="text-align: left;">    setStatus(&#39;IDLE&#39;);</p><p style="text-align: left;">    setResult(null);</p><p style="text-align: left;">    setError(null);</p><p style="text-align: left;"></p><p style="text-align: left;">    try {</p><p style="text-align: left;">      setStatus(&#39;ACCEPTED&#39;); // Indicate submission attempt</p><p style="text-align: left;">      const taskResponse = await taskStartFunction(); // Call the provided function to start task</p><p style="text-align: left;">      if (taskResponse &#38;&#38; taskResponse.task_id) {</p><p style="text-align: left;">          setTaskId(taskResponse.task_id);</p><p style="text-align: left;">          // Initial status might be ACCEPTED or PENDING depending on backend speed</p><p style="text-align: left;">          setStatus(taskResponse.status || &#39;PENDING&#39;); </p><p style="text-align: left;">          // Poll immediately once after getting task ID</p><p style="text-align: left;">          pollStatus(taskResponse.task_id); </p><p style="text-align: left;">      } else {</p><p style="text-align: left;">          throw new Error(&#34;Invalid task response received from API.&#34;);</p><p style="text-align: left;">      }</p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      console.error(&#34;Error starting task:&#34;, err);</p><p style="text-align: left;">      setError(err.detail || err.message || &#39;Failed to start task.&#39;);</p><p style="text-align: left;">      setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">       setTaskId(null); // Ensure taskId is null on startup failure</p><p style="text-align: left;">    }</p><p style="text-align: left;">  }, [pollStatus, stopPolling]); // Include dependencies</p><p style="text-align: left;"></p><p style="text-align: left;">  return { taskId, status, result, error, startTask };</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default useTaskPolling;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(g) Create Placeholder Components:</p><p style="text-align: left;">Create files like Summarizer.js, Translator.js, DocQA.js, Transcriber.js, TTSPlayer.js, CodeGen.js, ZeroShotClassifier.js, NERExtractor.js inside frontend/src/components/. Fill them with a basic structure similar to SentimentAnalyzer.js or ImageGenerator.js, including:</p><p style="text-align: left;">* Imports (React, useState, apiService functions, the useTaskPolling hook if applicable).</p><p style="text-align: left;">* Input elements relevant to the task.</p><p style="text-align: left;">* A submit button/handler calling the appropriate apiService function (and startTask from the hook if polling).</p><p style="text-align: left;">* Display areas for loading state, errors, and the expected result format (referencing models.py for expected keys).</p><p style="text-align: left;"></p><p style="text-align: left;">(h) Update CSS (frontend/src/components/Components.css &#38; frontend/src/App.css): Add basic styling for the navbar, footer, and ensure consistent padding/margins.</p><p style="text-align: left;"></p><p style="text-align: left;">6. Running the Expanded Skeleton</p><p style="text-align: left;"></p><p style="text-align: left;">Backend: Same as before (ensure .env is correct, run pip install -r requirements.txt, then uvicorn app.main:app --reload --port 8000).</p><p style="text-align: left;">Frontend: Same as before (npm install react-router-dom axios if not already done, then npm start).</p><p style="text-align: left;">Conclusion &#38; Next Steps</p><p style="text-align: left;"></p><p style="text-align: left;">This expanded skeleton now includes:</p><p style="text-align: left;"></p><p style="text-align: left;">Functional backend endpoints for all features, using BackgroundTasks for longer operations.</p><p style="text-align: left;">Refined Pydantic models and basic configuration management.</p><p style="text-align: left;">A routed React frontend with placeholder components for all features.</p><p style="text-align: left;">A reusable polling hook (useTaskPolling) for background tasks.</p><p style="text-align: left;">Examples of both synchronous (Sentiment) and asynchronous (Image Gen) frontend implementations using a service layer.</p><p style="text-align: left;">Crucial Next Steps:</p><p style="text-align: left;"></p><p style="text-align: left;">Implement Placeholder Frontend Components: Flesh out the UI and API call logic for all the components created in step (g).</p><p style="text-align: left;">Implement Real Background Tasks: Replace FastAPI BackgroundTasks and the in-memory task_storage with Celery and Redis/RabbitMQ for robust, persistent background job processing. This is essential for production.</p><p style="text-align: left;">Implement Database: Add database models (SQLAlchemy), connection logic, and CRUD operations for users, history, saved results, etc.</p><p style="text-align: left;">Implement Authentication: Integrate fastapi-users or another library, protect endpoints, manage tokens on frontend.</p><p style="text-align: left;">Refine Error Handling: Add more specific error catching, user-friendly messages, and potentially logging integrations.</p><p style="text-align: left;">Testing: Write comprehensive tests.</p><p style="text-align: left;">Deployment: Plan and execute deployment.</p><p style="text-align: left;">This provides a significantly more developed foundation to build upon.</p><p style="text-align: left;">Okay, let&#39;s proceed with the next crucial steps, starting with replacing the in-memory BackgroundTasks with a proper background task queue using Celery and Redis.</p><p style="text-align: left;"></p><p style="text-align: left;">Requirement: You need to have Redis installed and running locally for this setup. The easiest way is often using Docker: docker run -d -p 6379:6379 --name my-redis redis</p><p style="text-align: left;"></p><p style="text-align: left;">Phase 2.1: Implement Real Background Tasks (Celery + Redis)</p><p style="text-align: left;"></p><p style="text-align: left;">(1) Update Backend Dependencies (backend/requirements.txt)</p><p style="text-align: left;"></p><p style="text-align: left;">Add celery and redis (with hiredis for performance):</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi</p><p style="text-align: left;"> uvicorn[standard]</p><p style="text-align: left;"> requests</p><p style="text-align: left;"> python-dotenv</p><p style="text-align: left;"> pydantic</p><p style="text-align: left;"> python-multipart</p><p style="text-align: left;">+# --- Add Celery and Redis ---</p><p style="text-align: left;">+celery[redis]</p><p style="text-align: left;">+redis[hiredis]</p><p style="text-align: left;">+# --- End Add ---</p><p style="text-align: left;"> # Add later: sqlalchemy[asyncio], psycopg2-binary, fastapi-users[sqlalchemy], python-jose[cryptography], pypdf2, Pillow, pydub, langdetect</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Diff</p><p style="text-align: left;">Install the new dependencies: pip install -r requirements.txt</p><p style="text-align: left;">(2) Configure Celery (backend/app/celery_app.py - NEW FILE)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/celery_app.py</p><p style="text-align: left;">import os</p><p style="text-align: left;">from celery import Celery</p><p style="text-align: left;">from dotenv import load_dotenv</p><p style="text-align: left;"></p><p style="text-align: left;">load_dotenv()</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Make Redis URL configurable via .env</p><p style="text-align: left;">REDIS_URL = os.getenv(&#34;REDIS_URL&#34;, &#34;redis://localhost:6379/0&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># Create Celery instance</p><p style="text-align: left;"># &#39;tasks&#39; is the default name, refers to the module where tasks are defined</p><p style="text-align: left;"># Use Redis as both the message broker and the result backend</p><p style="text-align: left;">celery_app = Celery(</p><p style="text-align: left;">    &#34;worker&#34;, # Can be any name, often matches the task module</p><p style="text-align: left;">    broker=REDIS_URL,</p><p style="text-align: left;">    backend=REDIS_URL,</p><p style="text-align: left;">    include=[&#39;app.tasks&#39;] # Tell Celery where to find task definitions</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Optional Celery configuration</p><p style="text-align: left;">celery_app.conf.update(</p><p style="text-align: left;">    task_serializer=&#39;json&#39;,</p><p style="text-align: left;">    accept_content=[&#39;json&#39;],  # Ignore other content</p><p style="text-align: left;">    result_serializer=&#39;json&#39;,</p><p style="text-align: left;">    timezone=&#39;UTC&#39;,</p><p style="text-align: left;">    enable_utc=True,</p><p style="text-align: left;">    # Set task time limits later if needed</p><p style="text-align: left;">    # task_soft_time_limit=300, # 5 minutes soft limit</p><p style="text-align: left;">    # task_time_limit=360,      # 6 minutes hard limit</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;">if __name__ == &#39;__main__&#39;:</p><p style="text-align: left;">    celery_app.start() # Allows running worker directly (python -m app.celery_app worker -l info)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(3) Update Task Logic (backend/app/tasks.py - MAJOR REFACTOR)</p><p style="text-align: left;"></p><p style="text-align: left;">Remove the old in-memory storage and redefine tasks using the Celery decorator. Celery handles state and results via the backend (Redis).</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/tasks.py</p><p style="text-align: left;">import requests</p><p style="text-align: left;">import os</p><p style="text-align: left;">import base64</p><p style="text-align: left;">import time</p><p style="text-align: left;">from celery import shared_task # Import shared_task decorator</p><p style="text-align: left;">from celery.result import AsyncResult</p><p style="text-align: left;">from typing import Dict, Any</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"></p><p style="text-align: left;"># Removed: In-memory task_storage dictionary</p><p style="text-align: left;"></p><p style="text-align: left;">HEADERS = {&#34;Authorization&#34;: f&#34;Bearer {settings.HF_API_TOKEN}&#34;}</p><p style="text-align: left;"></p><p style="text-align: left;"># Helper function remains largely the same, but now returns results/errors</p><p style="text-align: left;">def _make_hf_request(model_id: str, payload: Dict[str, Any], is_image_output: bool = False, is_audio_output: bool = False) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Internal helper to make the actual HF API request and handle response types.&#34;&#34;&#34;</p><p style="text-align: left;">    api_url = f&#34;{settings.HF_API_BASE_URL}{model_id}&#34;</p><p style="text-align: left;">    result_payload = {}</p><p style="text-align: left;">    error_payload = None</p><p style="text-align: left;">    print(f&#34;Making HF API call to: {api_url}&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        response = requests.post(api_url, headers=HEADERS, json=payload, timeout=300) # Longer timeout for potentially slow models</p><p style="text-align: left;">        content_type = response.headers.get(&#39;Content-Type&#39;, &#39;&#39;)</p><p style="text-align: left;"></p><p style="text-align: left;">        if response.status_code == 503: # Model loading</p><p style="text-align: left;">            error_payload = f&#34;Model {model_id} is loading (503), please try again later.&#34;</p><p style="text-align: left;">            print(error_payload)</p><p style="text-align: left;">            # Raise an exception that Celery can catch and mark as failure</p><p style="text-align: left;">            raise ValueError(error_payload)</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_image_output and content_type.startswith(&#39;image/&#39;):</p><p style="text-align: left;">            if response.ok:</p><p style="text-align: left;">                image_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;image_base64&#34;: image_base64}</p><p style="text-align: left;">                print(f&#34;Image received for model {model_id}&#34;)</p><p style="text-align: left;">            else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for image: {response.text}&#34;</p><p style="text-align: left;">                print(error_payload)</p><p style="text-align: left;">                raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_audio_output and content_type.startswith(&#39;audio/&#39;):</p><p style="text-align: left;">            if response.ok:</p><p style="text-align: left;">                audio_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;audio_base64&#34;: audio_base64}</p><p style="text-align: left;">                print(f&#34;Audio received for model {model_id}&#34;)</p><p style="text-align: left;">            else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for audio: {response.text}&#34;</p><p style="text-align: left;">                print(error_payload)</p><p style="text-align: left;">                raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;"></p><p style="text-align: left;">        elif content_type.startswith(&#39;application/json&#39;) or response.ok:</p><p style="text-align: left;">            try:</p><p style="text-align: left;">                result_data = response.json()</p><p style="text-align: left;">                response.raise_for_status() # Check for other HTTP errors</p><p style="text-align: left;">                # The actual result might be nested</p><p style="text-align: left;">                if isinstance(result_data, list) and result_data:</p><p style="text-align: left;">                    result_payload = result_data[0] # Assume first element is primary result</p><p style="text-align: left;">                elif isinstance(result_data, dict):</p><p style="text-align: left;">                    result_payload = result_data</p><p style="text-align: left;">                else:</p><p style="text-align: left;">                     result_payload = {&#34;raw_response&#34;: result_data} # Fallback</p><p style="text-align: left;">                print(f&#34;JSON response received for model {model_id}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">            except requests.exceptions.JSONDecodeError:</p><p style="text-align: left;">                if response.ok:</p><p style="text-align: left;">                     error_payload = f&#34;Received non-JSON success ({response.status_code}). Body: {response.text[:100]}...&#34;</p><p style="text-align: left;">                     print(error_payload)</p><p style="text-align: left;">                     raise ValueError(error_payload) # Treat as failure</p><p style="text-align: left;">                else:</p><p style="text-align: left;">                     error_payload = f&#34;API Error {response.status_code}: {response.text}&#34;</p><p style="text-align: left;">                     print(error_payload)</p><p style="text-align: left;">                     raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;">            except requests.exceptions.HTTPError as e:</p><p style="text-align: left;">                 # If raise_for_status fails after JSON parse</p><p style="text-align: left;">                 error_payload = f&#34;API HTTP Error {response.status_code}: {e}. Response: {result_data}&#34;</p><p style="text-align: left;">                 print(error_payload)</p><p style="text-align: left;">                 raise e # Reraise the original HTTPError</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            error_payload = f&#34;Unhandled API Error {response.status_code} (Content-Type: {content_type}): {response.text}&#34;</p><p style="text-align: left;">            print(error_payload)</p><p style="text-align: left;">            raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;"></p><p style="text-align: left;">    except requests.exceptions.Timeout:</p><p style="text-align: left;">         error_payload = f&#34;API Request timed out for {model_id}&#34;</p><p style="text-align: left;">         print(error_payload)</p><p style="text-align: left;">         raise TimeoutError(error_payload) # Use specific exception</p><p style="text-align: left;">    except requests.exceptions.RequestException as e:</p><p style="text-align: left;">        error_payload = f&#34;API Request failed for {model_id}: {e}&#34;</p><p style="text-align: left;">        print(error_payload)</p><p style="text-align: left;">        raise e # Reraise request exceptions</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        error_payload = f&#34;Unexpected error during API call for {model_id}: {type(e).__name__} - {e}&#34;</p><p style="text-align: left;">        print(error_payload)</p><p style="text-align: left;">        raise e # Reraise other exceptions</p><p style="text-align: left;"></p><p style="text-align: left;">    # Return the successful result payload</p><p style="text-align: left;">    return result_payload</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Define Celery Tasks ---</p><p style="text-align: left;"></p><p style="text-align: left;">@shared_task(bind=True, max_retries=3) # Use shared_task, bind=True gives access to self</p><p style="text-align: left;">def celery_hf_inference_task(self, model_id: str, payload: Dict[str, Any], task_type: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Generic Celery task to run inference via the helper function.&#34;&#34;&#34;</p><p style="text-align: left;">    print(f&#34;Celery task {self.request.id} ({task_type}) started for model {model_id}&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        is_image = task_type == &#34;image_generation&#34;</p><p style="text-align: left;">        is_audio = task_type in [&#34;transcription&#34;, &#34;tts&#34;] # Assuming transcription returns audio bytes</p><p style="text-align: left;">        </p><p style="text-align: left;">        # --- SPECIAL HANDLING for Transcription ---</p><p style="text-align: left;">        # The HF API for transcription often expects raw audio bytes.</p><p style="text-align: left;">        # The &#39;payload&#39; here might need to contain the bytes if passed from API</p><p style="text-align: left;">        # OR this task needs to load the audio data from storage based on an ID in the payload.</p><p style="text-align: left;">        # This is a complex part needing specific implementation based on how audio is handled.</p><p style="text-align: left;">        # For now, we assume payload is JSON and _make_hf_request needs adjustment</p><p style="text-align: left;">        # OR that transcription model API accepts JSON (less common).</p><p style="text-align: left;">        # --&#62; We will proceed assuming payload is JSON for consistency here, but mark transcription as potentially problematic.</p><p style="text-align: left;">        if task_type == &#34;transcription&#34;:</p><p style="text-align: left;">             print(f&#34;WARNING: Transcription task ({self.request.id}) assumes JSON payload for API call. Raw audio bytes handling likely needed in _make_hf_request or via file storage.&#34;)</p><p style="text-align: left;">             # Example adjustment if payload had audio bytes encoded:</p><p style="text-align: left;">             # if &#39;audio_b64&#39; in payload:</p><p style="text-align: left;">             #    audio_bytes = base64.b64decode(payload[&#39;audio_b64&#39;])</p><p style="text-align: left;">             #    # Need to modify _make_hf_request to send &#39;data=audio_bytes&#39;</p><p style="text-align: left;">             # else: raise ValueError(&#34;Missing audio data for transcription task&#34;)</p><p style="text-align: left;">             pass # Continue assuming JSON payload for now</p><p style="text-align: left;"></p><p style="text-align: left;">        # Add a small delay before actual call (optional, for simulation)</p><p style="text-align: left;">        # time.sleep(2)</p><p style="text-align: left;">        </p><p style="text-align: left;">        result = _make_hf_request(model_id, payload, is_image_output=is_image, is_audio_output=is_audio)</p><p style="text-align: left;">        </p><p style="text-align: left;">        print(f&#34;Celery task {self.request.id} completed successfully.&#34;)</p><p style="text-align: left;">        # Celery stores the return value automatically in the result backend (Redis)</p><p style="text-align: left;">        return result </p><p style="text-align: left;"></p><p style="text-align: left;">    except Exception as exc:</p><p style="text-align: left;">        print(f&#34;Celery task {self.request.id} failed: {exc}&#34;)</p><p style="text-align: left;">        # Retry logic (Celery handles retries based on decorator)</p><p style="text-align: left;">        # Optionally, update task state with specific error info if needed beyond exception</p><p style="text-align: left;">        # self.update_state(state=&#39;FAILURE&#39;, meta={&#39;exc_type&#39;: type(exc).__name__, &#39;exc_message&#39;: str(exc)})</p><p style="text-align: left;">        # Re-raise the exception to trigger Celery&#39;s retry/failure handling</p><p style="text-align: left;">        raise exc # Ensures task state becomes FAILURE if retries exhausted</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Function to check Celery task status ---</p><p style="text-align: left;">def get_celery_task_status(task_id: str) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets status and result from the Celery backend.&#34;&#34;&#34;</p><p style="text-align: left;">    task_result = AsyncResult(task_id) # Get result object from Celery backend</p><p style="text-align: left;">    </p><p style="text-align: left;">    status = task_result.status</p><p style="text-align: left;">    result_data = None</p><p style="text-align: left;">    error_info = None</p><p style="text-align: left;"></p><p style="text-align: left;">    if task_result.successful():</p><p style="text-align: left;">        status = &#34;SUCCESS&#34;</p><p style="text-align: left;">        raw_result = task_result.result </p><p style="text-align: left;">        # Wrap result for consistency with our model</p><p style="text-align: left;">        result_data = {&#34;result_data&#34;: raw_result}</p><p style="text-align: left;">    elif task_result.failed():</p><p style="text-align: left;">        status = &#34;FAILURE&#34;</p><p style="text-align: left;">        # Get traceback or exception info</p><p style="text-align: left;">        error_info = str(task_result.info) # Info contains exception on failure</p><p style="text-align: left;">        print(f&#34;Task {task_id} failed in Celery: {error_info}&#34;)</p><p style="text-align: left;">    elif status in [&#39;PENDING&#39;, &#39;STARTED&#39;, &#39;RETRY&#39;]:</p><p style="text-align: left;">        status = &#34;PENDING&#34; # Consolidate intermediate states</p><p style="text-align: left;">    else:</p><p style="text-align: left;">        status = status # Keep other states like REVOKED if needed</p><p style="text-align: left;"></p><p style="text-align: left;">    return {</p><p style="text-align: left;">        &#34;task_id&#34;: task_id,</p><p style="text-align: left;">        &#34;status&#34;: status,</p><p style="text-align: left;">        &#34;result&#34;: result_data,</p><p style="text-align: left;">        &#34;error&#34;: error_info</p><p style="text-align: left;">    }</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(4) Update Service Logic (backend/app/services.py - Use Celery)</p><p style="text-align: left;"></p><p style="text-align: left;">Modify start_background_task and get_task_status_info. Remove the simple BackgroundTasks version.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/services.py</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">from fastapi import HTTPException # Removed BackgroundTasks import</p><p style="text-align: left;">from typing import Dict, Any, Optional, List</p><p style="text-align: left;">from . import tasks # Import task definitions AND status checker</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .celery_app import celery_app # Import the celery app instance</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Task Submission Service Functions ---</p><p style="text-align: left;"></p><p style="text-align: left;"># Removed: start_simple_inference (can be done via background task now, or keep if truly needed)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_background_task_celery(</p><p style="text-align: left;">    model_id: str,</p><p style="text-align: left;">    payload: Dict[str, Any],</p><p style="text-align: left;">    task_type: str # Helps the runner know how to handle response</p><p style="text-align: left;">) -&#62; str:</p><p style="text-align: left;">    &#34;&#34;&#34;Dispatches a task to the Celery queue.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Use .delay() for simple execution</p><p style="text-align: left;">        task = tasks.celery_hf_inference_task.delay(model_id, payload, task_type)</p><p style="text-align: left;">        # Or use .apply_async() for more options (e.g., countdown, eta)</p><p style="text-align: left;">        # task = tasks.celery_hf_inference_task.apply_async(args=[model_id, payload, task_type])</p><p style="text-align: left;">        </p><p style="text-align: left;">        print(f&#34;Task {task.id} dispatched to Celery ({task_type} on {model_id})&#34;)</p><p style="text-align: left;">        return task.id # Return the Celery task ID</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        # Catch errors during task dispatch itself (e.g., broker connection issues)</p><p style="text-align: left;">        print(f&#34;ERROR dispatching Celery task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to submit task to queue: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">def get_task_status_info_celery(task_id: str) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets status from the Celery backend via tasks module helper.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Use the helper function defined in tasks.py</p><p style="text-align: left;">        return tasks.get_celery_task_status(task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         # Handle potential errors talking to the backend (Redis)</p><p style="text-align: left;">         print(f&#34;ERROR retrieving Celery task status for {task_id}: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Error retrieving task status: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Specific Task Starters (Updated to use Celery dispatcher) ---</p><p style="text-align: left;"></p><p style="text-align: left;">def start_summarization(text: str, min_len: int, max_len: int) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;min_length&#34;: min_len, &#34;max_length&#34;: max_len}}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_SUMMARIZATION, payload, &#34;summarization&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_translation(text: str, source_lang: Optional[str], target_lang: str) -&#62; str:</p><p style="text-align: left;">    model_id = f&#34;{settings.MODEL_TRANSLATION_PREFIX}{source_lang or &#39;en&#39;}-{target_lang}&#34;</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task_celery(model_id, payload, &#34;translation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_image_generation(prompt: str, negative_prompt: Optional[str]) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt}</p><p style="text-align: left;">    if negative_prompt:</p><p style="text-align: left;">        payload[&#34;parameters&#34;] = {&#34;negative_prompt&#34;: negative_prompt}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_IMAGE_GEN, payload, &#34;image_generation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_doc_qa(context: str, question: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: {&#34;question&#34;: question, &#34;context&#34;: context}}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_DOC_QA, payload, &#34;question_answering&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_transcription(audio_bytes: bytes) -&#62; str:</p><p style="text-align: left;">    # How to pass bytes to Celery?</p><p style="text-align: left;">    # Option 1: Encode as Base64 string in payload (preferred for JSON serialization)</p><p style="text-align: left;">    # Option 2: Store bytes temporarily (e.g., S3, local file if worker shares FS), pass ID/path in payload.</p><p style="text-align: left;">    # We choose Option 1 here for simplicity. Task needs to decode.</p><p style="text-align: left;">    audio_b64 = base64.b64encode(audio_bytes).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">    payload = {&#34;audio_b64&#34;: audio_b64} # Task needs to decode this</p><p style="text-align: left;">    print(f&#34;Dispatching transcription task, payload size hint (b64): {len(audio_b64)}&#34;)</p><p style="text-align: left;">    # WARNING: Make sure the task `celery_hf_inference_task` is updated to handle this payload</p><p style="text-align: left;">    # AND that the underlying _make_hf_request can send raw bytes.</p><p style="text-align: left;">    # This part remains complex and needs real API endpoint testing.</p><p style="text-align: left;">    # For now, sending the encoded data.</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_TRANSCRIPTION, payload, &#34;transcription&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_tts(text: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_TTS, payload, &#34;tts&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_code_generation(prompt: str, language: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt, &#34;parameters&#34;: {&#34;return_full_text&#34;: False}}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_CODE_GEN, payload, &#34;code_generation&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_zero_shot(text: str, labels: List[str]) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;candidate_labels&#34;: labels}}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_ZERO_SHOT, payload, &#34;zero_shot&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">def start_ner(text: str) -&#62; str:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return start_background_task_celery(settings.MODEL_NER, payload, &#34;ner&#34;)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(5) Update API Logic (backend/app/api.py - Remove BackgroundTasks, Use Celery Services)</p><p style="text-align: left;"></p><p style="text-align: left;">Modify endpoints that were using BackgroundTasks to use the new Celery service functions. Remove the background_tasks: BackgroundTasks dependency injection from those endpoints.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/api.py</p><p style="text-align: left;">from fastapi import APIRouter, HTTPException, Depends, UploadFile, File # Removed BackgroundTasks</p><p style="text-align: left;">from typing import List, Optional</p><p style="text-align: left;">from . import models</p><p style="text-align: left;">from . import services # Uses Celery-based services now</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"># TODO: Auth dependencies</p><p style="text-align: left;"></p><p style="text-align: left;">router = APIRouter()</p><p style="text-align: left;"></p><p style="text-align: left;">def _parse_task_result(task_data: dict) -&#62; Optional[models.TaskResult]:</p><p style="text-align: left;">     # ...(Same parsing logic as before)...</p><p style="text-align: left;">     # Important: Ensure the keys used here match the structure returned by </p><p style="text-align: left;">     # the Celery task (which comes from _make_hf_request helper)</p><p style="text-align: left;">     if task_data.get(&#34;status&#34;) == &#34;SUCCESS&#34; and &#34;result&#34; in task_data:</p><p style="text-align: left;">         raw_result = task_data[&#34;result&#34;].get(&#34;result_data&#34;) # Data is nested by get_celery_task_status</p><p style="text-align: left;">         if raw_result is None: return None # Handle case where result itself is None</p><p style="text-align: left;"></p><p style="text-align: left;">         if isinstance(raw_result, dict):</p><p style="text-align: left;">             if &#34;summary_text&#34; in raw_result: return models.TaskResult(result_data=models.SummaryResult(**raw_result))</p><p style="text-align: left;">             if &#34;translation_text&#34; in raw_result: return models.TaskResult(result_data=models.TranslationResult(**raw_result))</p><p style="text-align: left;">             if &#34;image_base64&#34; in raw_result: return models.TaskResult(result_data=models.ImageGenResult(**raw_result))</p><p style="text-align: left;">             if &#34;entities&#34; in raw_result: return models.TaskResult(result_data=models.NerResult(**raw_result))</p><p style="text-align: left;">             if &#34;answer&#34; in raw_result: return models.TaskResult(result_data=models.QAResult(**raw_result))</p><p style="text-align: left;">             if &#34;labels&#34; in raw_result and &#34;scores&#34; in raw_result: return models.TaskResult(result_data=models.ZeroShotResult(**raw_result))</p><p style="text-align: left;">             if &#34;generated_code&#34; in raw_result: return models.TaskResult(result_data=models.CodeGenResult(**raw_result))</p><p style="text-align: left;">             if &#34;audio_base64&#34; in raw_result: return models.TaskResult(result_data=models.TextToSpeechResult(**raw_result))</p><p style="text-align: left;">             # Check for transcription result key (assuming &#39;text&#39; for whisper common output)</p><p style="text-align: left;">             if &#34;text&#34; in raw_result and task_data.get(&#34;task_type_hint&#34;) == &#34;transcription&#34;: </p><p style="text-align: left;">                   return models.TaskResult(result_data=models.TranscriptionResult(transcription_text=raw_result[&#34;text&#34;]))</p><p style="text-align: left;">             # Fallback for unparsed but successful dict results</p><p style="text-align: left;">             return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">         elif isinstance(raw_result, str): # Simple string result (possible for some tasks)</p><p style="text-align: left;">             # Need context to know *which* task type returned a string</p><p style="text-align: left;">             # We&#39;ll add a hint for transcription for now</p><p style="text-align: left;">             if task_data.get(&#34;task_type_hint&#34;) == &#34;transcription&#34;:</p><p style="text-align: left;">                  return models.TaskResult(result_data=models.TranscriptionResult(transcription_text=raw_result))</p><p style="text-align: left;">             # Add more specific string checks if other tasks return plain strings</p><p style="text-align: left;">             else:</p><p style="text-align: left;">                   return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">         else: # Other primitive types</p><p style="text-align: left;">              return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">     return None # Not SUCCESS or no result key</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/sentiment&#34;, response_model=models.SentimentResult, responses={500: {&#34;model&#34;: models.ErrorResponse}, 503: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def analyze_sentiment(data: models.TextInput): # Stays synchronous</p><p style="text-align: left;">    &#34;&#34;&#34;Analyzes sentiment using a suitable HF model (synchronous).&#34;&#34;&#34;</p><p style="text-align: left;">    # ... (Keep existing synchronous implementation using services.start_simple_inference) ...</p><p style="text-align: left;">    # OR convert it to use background tasks if even sentiment might be slow sometimes</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Synchronous call using the direct helper for speed if model is fast</p><p style="text-align: left;">        result = tasks._make_hf_request(settings.MODEL_SENTIMENT, {&#34;inputs&#34;: data.text})</p><p style="text-align: left;">        if &#34;error&#34; in result:</p><p style="text-align: left;">             detail = result[&#39;error&#39;]</p><p style="text-align: left;">             status_code = 503 if &#34;loading&#34; in detail.lower() else 500</p><p style="text-align: left;">             raise HTTPException(status_code=status_code, detail=detail)</p><p style="text-align: left;">        </p><p style="text-align: left;">        if result and isinstance(result, list) and result[0] and isinstance(result[0], list):</p><p style="text-align: left;">            scores = [models.SentimentScore(**item) for item in result[0]]</p><p style="text-align: left;">            return models.SentimentResult(sentiment=scores)</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            print(f&#34;Unexpected sentiment response format: {result}&#34;)</p><p style="text-align: left;">            raise HTTPException(status_code=500, detail=&#34;Could not parse sentiment response from HF API&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error in sentiment endpoint: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Internal server error: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Endpoints now dispatching Celery tasks ---</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/summarize&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def summarize_text(data: models.SummarizationRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text summarization via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_summarization(data.text, data.min_length, data.max_length)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting summarization task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Failed to start summarization task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/translate&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def translate_text(data: models.TranslationRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for translation via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.target_lang or len(data.target_lang) &#60; 2:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Invalid target language code.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_translation(data.text, data.source_lang, data.target_lang)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting translation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start translation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-image&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_image(data: models.ImageGenRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for image generation via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Prompt cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_image_generation(data.prompt, data.negative_prompt)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting image generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start image generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/qa-document&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def qa_document(data: models.DocQARequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Document Question Answering via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.context or not data.question:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Context and question cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_doc_qa(data.context, data.question)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting QA task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start QA task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/transcribe&#34;, response_model=models.TaskResponse, responses={400: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def transcribe_audio(file: UploadFile = File(...)): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for audio transcription via Celery (accepts file upload).&#34;&#34;&#34;</p><p style="text-align: left;">    if not file.content_type.startswith(&#34;audio/&#34;):</p><p style="text-align: left;">         raise HTTPException(status_code=400, detail=&#34;Invalid file type. Please upload an audio file.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        audio_bytes = await file.read()</p><p style="text-align: left;">        if not audio_bytes:</p><p style="text-align: left;">             raise HTTPException(status_code=400, detail=&#34;Uploaded file is empty.&#34;)</p><p style="text-align: left;">        # Pass bytes directly to the service function which will handle encoding/dispatch</p><p style="text-align: left;">        task_id = services.start_transcription(audio_bytes)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting transcription task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to process file or start transcription task: {e}&#34;)</p><p style="text-align: left;">    finally:</p><p style="text-align: left;">        await file.close()</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/text-to-speech&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def text_to_speech(data: models.TextToSpeechRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text-to-speech synthesis via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_tts(data.text)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting TTS task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start TTS task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-code&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_code(data: models.CodeGenRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for code generation via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt or not data.language:</p><p style="text-align: left;">        raise HTTPException(status_code=422, detail=&#34;Prompt and language are required.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_code_generation(data.prompt, data.language)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting code generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start code generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/classify-zero-shot&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def classify_zero_shot(data: models.ZeroShotRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for zero-shot text classification via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text or not data.candidate_labels:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text and candidate labels are required.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         task_id = services.start_zero_shot(data.text, data.candidate_labels)</p><p style="text-align: left;">         return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting zero-shot classification task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start zero-shot classification task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/extract-entities&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def extract_entities(data: models.NerRequest): # Removed background_tasks</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Named Entity Recognition via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        task_id = services.start_ner(data.text)</p><p style="text-align: left;">        return models.TaskResponse(task_id=task_id)</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting NER task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start NER task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Central Task Status Endpoint (Uses Celery Service) ---</p><p style="text-align: left;">@router.get(&#34;/api/task-status/{task_id}&#34;, response_model=models.TaskStatusResponse, responses={404: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def get_task_status_endpoint(task_id: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Polls for the status and result of any background task via Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Get status directly using the Celery-aware service function</p><p style="text-align: left;">        status_data = services.get_task_status_info_celery(task_id)</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Add task type hint if possible (e.g., store it when task is created - more advanced)</p><p style="text-align: left;">        # This helps the parser distinguish ambiguous result types</p><p style="text-align: left;">        # For now, we don&#39;t have it readily available here. Parsing relies on unique keys.</p><p style="text-align: left;">        parsed_result = _parse_task_result(status_data) </p><p style="text-align: left;">        </p><p style="text-align: left;">        response_payload = {**status_data, &#34;result&#34;: parsed_result}</p><p style="text-align: left;">        return models.TaskStatusResponse(**response_payload)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error getting task status for {task_id}: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Internal server error retrieving task status: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add endpoints for User Authentication (Register, Login, Get Me)</p><p style="text-align: left;"># TODO: Add endpoints for saving/retrieving results from DB</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(6) Frontend (frontend/src/hooks/useTaskPolling.js - Needs slight update)</p><p style="text-align: left;"></p><p style="text-align: left;">Ensure the hook correctly handles the ACCEPTED state returned initially by the backend when using Celery.</p><p style="text-align: left;"></p><p style="text-align: left;">// frontend/src/hooks/useTaskPolling.js</p><p style="text-align: left;">// ... (imports) ...</p><p style="text-align: left;"></p><p style="text-align: left;">function useTaskPolling(getStatusFunction, pollInterval = 3000) {</p><p style="text-align: left;">  // ... (useState, useRef hooks remain the same) ...</p><p style="text-align: left;">  const [taskId, setTaskId] = useState(null);</p><p style="text-align: left;">  const [status, setStatus] = useState(&#39;IDLE&#39;); // IDLE, ACCEPTED, PENDING, SUCCESS, FAILURE, NOT_FOUND</p><p style="text-align: left;">  const [result, setResult] = useState(null);</p><p style="text-align: left;">  const [error, setError] = useState(null);</p><p style="text-align: left;">  const intervalRef = useRef(null);</p><p style="text-align: left;"></p><p style="text-align: left;">  const stopPolling = useCallback(() =&#62; {</p><p style="text-align: left;">      // ... (same as before) ...</p><p style="text-align: left;">  }, []);</p><p style="text-align: left;"></p><p style="text-align: left;">  const pollStatus = useCallback(async (currentTaskId) =&#62; {</p><p style="text-align: left;">      // ... (same as before, checks for SUCCESS, FAILURE, NOT_FOUND) ...</p><p style="text-align: left;">       if (!currentTaskId) {</p><p style="text-align: left;">            stopPolling();</p><p style="text-align: left;">            return;</p><p style="text-align: left;">       }</p><p style="text-align: left;">       try {</p><p style="text-align: left;">           const data = await getStatusFunction(currentTaskId); </p><p style="text-align: left;">           setStatus(data.status); // Update status based on backend response</p><p style="text-align: left;"></p><p style="text-align: left;">           if (data.status === &#39;SUCCESS&#39;) {</p><p style="text-align: left;">               setResult(data.result || null); </p><p style="text-align: left;">               setError(null);</p><p style="text-align: left;">               setTaskId(null); </p><p style="text-align: left;">               stopPolling();</p><p style="text-align: left;">           } else if (data.status === &#39;FAILURE&#39;) {</p><p style="text-align: left;">               setError(data.error || &#39;Task failed for an unknown reason.&#39;);</p><p style="text-align: left;">               setResult(null);</p><p style="text-align: left;">               setTaskId(null); </p><p style="text-align: left;">               stopPolling();</p><p style="text-align: left;">           } else if (data.status === &#39;NOT_FOUND&#39;) {</p><p style="text-align: left;">               setError(data.error || &#39;Task not found.&#39;);</p><p style="text-align: left;">               setResult(null);</p><p style="text-align: left;">               setTaskId(null);</p><p style="text-align: left;">               stopPolling();</p><p style="text-align: left;">           }</p><p style="text-align: left;">           // If PENDING or ACCEPTED, polling continues in useEffect</p><p style="text-align: left;">       } catch (err) {</p><p style="text-align: left;">           console.error(&#34;Polling error:&#34;, err);</p><p style="text-align: left;">           setError(err.detail || err.message || &#39;Failed to get task status.&#39;);</p><p style="text-align: left;">           setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">           setTaskId(null); </p><p style="text-align: left;">           stopPolling();</p><p style="text-align: left;">       }</p><p style="text-align: left;">  }, [getStatusFunction, stopPolling]);</p><p style="text-align: left;"></p><p style="text-align: left;">  useEffect(() =&#62; {</p><p style="text-align: left;">     // Keep polling if status is ACCEPTED or PENDING</p><p style="text-align: left;">    if (taskId &#38;&#38; (status === &#39;PENDING&#39; || status === &#39;ACCEPTED&#39;)) { </p><p style="text-align: left;">      stopPolling();</p><p style="text-align: left;">      intervalRef.current = setInterval(() =&#62; {</p><p style="text-align: left;">        pollStatus(taskId);</p><p style="text-align: left;">      }, pollInterval);</p><p style="text-align: left;">    } else {</p><p style="text-align: left;">       stopPolling();</p><p style="text-align: left;">    }</p><p style="text-align: left;">    return () =&#62; stopPolling();</p><p style="text-align: left;">  }, [taskId, status, pollInterval, pollStatus, stopPolling]);</p><p style="text-align: left;"></p><p style="text-align: left;">  const startTask = useCallback(async (taskStartFunction) =&#62; {</p><p style="text-align: left;">    stopPolling(); </p><p style="text-align: left;">    setTaskId(null);</p><p style="text-align: left;">    setStatus(&#39;IDLE&#39;);</p><p style="text-align: left;">    setResult(null);</p><p style="text-align: left;">    setError(null);</p><p style="text-align: left;"></p><p style="text-align: left;">    try {</p><p style="text-align: left;">      setStatus(&#39;SUBMITTING&#39;); // Indicate submission attempt</p><p style="text-align: left;">      const taskResponse = await taskStartFunction(); </p><p style="text-align: left;">      if (taskResponse &#38;&#38; taskResponse.task_id) {</p><p style="text-align: left;">          setTaskId(taskResponse.task_id);</p><p style="text-align: left;">          setStatus(taskResponse.status || &#39;ACCEPTED&#39;); // Use status from backend response</p><p style="text-align: left;">          // Poll immediately once after getting task ID</p><p style="text-align: left;">          pollStatus(taskResponse.task_id);</p><p style="text-align: left;">      } else {</p><p style="text-align: left;">          throw new Error(&#34;Invalid task response received from API.&#34;);</p><p style="text-align: left;">      }</p><p style="text-align: left;">    } catch (err) {</p><p style="text-align: left;">      console.error(&#34;Error starting task:&#34;, err);</p><p style="text-align: left;">      setError(err.detail || err.message || &#39;Failed to start task.&#39;);</p><p style="text-align: left;">      setStatus(&#39;FAILURE&#39;);</p><p style="text-align: left;">       setTaskId(null); </p><p style="text-align: left;">    }</p><p style="text-align: left;">  }, [pollStatus, stopPolling]); // pollStatus needed here</p><p style="text-align: left;"></p><p style="text-align: left;">  return { taskId, status, result, error, startTask };</p><p style="text-align: left;">}</p><p style="text-align: left;"></p><p style="text-align: left;">export default useTaskPolling;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">JavaScript</p><p style="text-align: left;">(7) Add Instructions for Running</p><p style="text-align: left;"></p><p style="text-align: left;">Start Redis: docker run -d -p 6379:6379 --name my-redis redis (if using Docker)</p><p style="text-align: left;">Start Backend: Navigate to backend/, activate venv, run uvicorn app.main:app --reload --port 8000</p><p style="text-align: left;">Start Celery Worker: Open a new terminal, navigate to backend/, activate venv, run celery -A app.celery_app worker --loglevel=info</p><p style="text-align: left;">Start Frontend: Navigate to frontend/, run npm start</p><p style="text-align: left;">Summary of Changes &#38; Next Steps:</p><p style="text-align: left;"></p><p style="text-align: left;">We replaced FastAPI BackgroundTasks and the in-memory store with Celery and Redis.</p><p style="text-align: left;">Backend endpoints now dispatch tasks to the Celery queue and return a task ID immediately.</p><p style="text-align: left;">The /api/task-status/{task_id} endpoint now queries the Celery result backend (Redis).</p><p style="text-align: left;">Frontend polling logic handles the initial ACCEPTED state.</p><p style="text-align: left;">Placeholders and TODOs remain for Database, Auth, advanced error handling, specific HF API payload/response mapping (especially for audio/binary data), frontend component implementation, and production deployment/scaling.</p><p style="text-align: left;">The next logical steps would be Database Integration (SQLAlchemy + PostgreSQL/SQLite) and User Authentication (fastapi-users). This provides a significantly more robust foundation.</p><p style="text-align: left;">Okay, let&#39;s proceed with the next critical step: Database Integration. We&#39;ll integrate a database to store persistent information about tasks, results, and eventually users.</p><p style="text-align: left;"></p><p style="text-align: left;">We&#39;ll use SQLAlchemy (with its async support) and target PostgreSQL. For simpler local development, you could adapt this to use SQLite, but PostgreSQL is better for scalability.</p><p style="text-align: left;"></p><p style="text-align: left;">Requirement: You need PostgreSQL installed and a database created locally (or use a cloud-hosted one). For Docker: docker run -d -p 5432:5432 --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -e POSTGRES_DB=neuralblitz_db postgres</p><p style="text-align: left;"></p><p style="text-align: left;">Phase 2.2: Implement Database Integration (SQLAlchemy + PostgreSQL)</p><p style="text-align: left;"></p><p style="text-align: left;">(1) Update Backend Dependencies (backend/requirements.txt)</p><p style="text-align: left;"></p><p style="text-align: left;">Add sqlalchemy (with asyncio extras), psycopg2-binary (PostgreSQL driver), alembic (for migrations), and asyncpg (async PostgreSQL driver).</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi</p><p style="text-align: left;"> uvicorn[standard]</p><p style="text-align: left;"> requests</p><p style="text-align: left;"> python-dotenv</p><p style="text-align: left;"> pydantic</p><p style="text-align: left;"> python-multipart</p><p style="text-align: left;"> # --- Celery and Redis ---</p><p style="text-align: left;"> celery[redis]</p><p style="text-align: left;"> redis[hiredis]</p><p style="text-align: left;">+# --- Add Database Dependencies ---</p><p style="text-align: left;">+sqlalchemy[asyncio]</p><p style="text-align: left;">+psycopg2-binary</p><p style="text-align: left;">+alembic</p><p style="text-align: left;">+asyncpg</p><p style="text-align: left;">+# --- End Add ---</p><p style="text-align: left;"> # Add later: fastapi-users[sqlalchemy], python-jose[cryptography], pypdf2, Pillow, pub, langdetect</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Diff</p><p style="text-align: left;">Install the new dependencies: pip install -r requirements.txt</p><p style="text-align: left;">(2) Update Configuration (backend/.env and backend/app/config.py)</p><p style="text-align: left;"></p><p style="text-align: left;">Add the database connection string to your .env file:</p><p style="text-align: left;"></p><p style="text-align: left;">HUGGINGFACE_API_TOKEN=&#34;hf_YOUR_ACTUAL_HUGGINGFACE_TOKEN&#34;</p><p style="text-align: left;">+# Example for local PostgreSQL using Docker command above</p><p style="text-align: left;">+DATABASE_URL=&#34;postgresql+asyncpg://postgres:mysecretpassword@localhost:5432/neuralblitz_db&#34; </p><p style="text-align: left;">+# For SQLite (simpler local dev, adjust path):</p><p style="text-align: left;">+# DATABASE_URL=&#34;sqlite+aiosqlite:///./neuralblitz_dev.db&#34;</p><p style="text-align: left;"> # Add later: JWT_SECRET_KEY, REDIS_URL etc.</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Diff</p><p style="text-align: left;">Update backend/app/config.py:</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/config.py</p><p style="text-align: left;"> import os</p><p style="text-align: left;"> from dotenv import load_dotenv</p><p style="text-align: left;">-from pydantic import BaseSettings</p><p style="text-align: left;">+from pydantic import BaseSettings, validator</p><p style="text-align: left;"></p><p style="text-align: left;"> load_dotenv()</p><p style="text-align: left;"></p><p style="text-align: left;"> class Settings(BaseSettings):</p><p style="text-align: left;">     HF_API_TOKEN: str = os.getenv(&#34;HUGGINGFACE_API_TOKEN&#34;, &#34;YOUR_TOKEN_HERE&#34;)</p><p style="text-align: left;">     HF_API_BASE_URL: str = &#34;https://api-inference.huggingface.co/models/&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">     # --- Default Model IDs ---</p><p style="text-align: left;">     MODEL_SUMMARIZATION: str = &#34;facebook/bart-large-cnn&#34;</p><p style="text-align: left;">     MODEL_TRANSLATION_PREFIX: str = &#34;Helsinki-NLP/opus-mt-&#34;</p><p style="text-align: left;">     MODEL_SENTIMENT: str = &#34;distilbert-base-uncased-finetuned-sst-2-english&#34;</p><p style="text-align: left;">     MODEL_IMAGE_GEN: str = &#34;stabilityai/stable-diffusion-xl-base-1.0&#34;</p><p style="text-align: left;">     MODEL_DOC_QA: str = &#34;deepset/roberta-base-squad2&#34;</p><p style="text-align: left;">     MODEL_TRANSCRIPTION: str = &#34;openai/whisper-large-v2&#34;</p><p style="text-align: left;">     MODEL_TTS: str = &#34;espnet/kan-bayashi_ljspeech_vits&#34;</p><p style="text-align: left;">     MODEL_CODE_GEN: str = &#34;codellama/CodeLlama-7b-hf&#34;</p><p style="text-align: left;">     MODEL_ZERO_SHOT: str = &#34;facebook/bart-large-mnli&#34;</p><p style="text-align: left;">     MODEL_NER: str = &#34;dbmdz/bert-large-cased-finetuned-conll03-english&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">     # --- Database Settings ---</p><p style="text-align: left;">     DATABASE_URL: str = os.getenv(&#34;DATABASE_URL&#34;, &#34;sqlite+aiosqlite:///./default_dev.db&#34;) # Default to SQLite if not set</p><p style="text-align: left;"></p><p style="text-align: left;">     # --- Celery/Redis ---</p><p style="text-align: left;">     CELERY_BROKER_URL: str = os.getenv(&#34;REDIS_URL&#34;, &#34;redis://localhost:6379/0&#34;)</p><p style="text-align: left;">     CELERY_RESULT_BACKEND: str = os.getenv(&#34;REDIS_URL&#34;, &#34;redis://localhost:6379/0&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">     # TODO: Add JWT Secret Key later for auth</p><p style="text-align: left;">     # JWT_SECRET_KEY: str = &#34;a_very_secret_key&#34;</p><p style="text-align: left;"></p><p style="text-align: left;">     # Simple check for placeholder token</p><p style="text-align: left;">     @validator(&#39;HF_API_TOKEN&#39;)</p><p style="text-align: left;">     def check_hf_token(cls, v):</p><p style="text-align: left;">         if v == &#34;YOUR_TOKEN_HERE&#34; or not v:</p><p style="text-align: left;">             print(&#34;\n**************************************************************&#34;)</p><p style="text-align: left;">             print(&#34;WARNING: HUGGINGFACE_API_TOKEN is not set or invalid in .env&#34;)</p><p style="text-align: left;">             print(&#34;API calls to Hugging Face will likely fail.&#34;)</p><p style="text-align: left;">             print(&#34;**************************************************************\n&#34;)</p><p style="text-align: left;">         return v</p><p style="text-align: left;">         </p><p style="text-align: left;">     # Add validator to ensure asyncpg URL uses correct scheme if needed</p><p style="text-align: left;">     @validator(&#39;DATABASE_URL&#39;)</p><p style="text-align: left;">     def check_db_url(cls, v):</p><p style="text-align: left;">         if v.startswith(&#34;postgresql://&#34;):</p><p style="text-align: left;">             # Automatically adjust for asyncpg if needed</p><p style="text-align: left;">             return v.replace(&#34;postgresql://&#34;, &#34;postgresql+asyncpg://&#34;, 1)</p><p style="text-align: left;">         elif v.startswith(&#34;sqlite://&#34;):</p><p style="text-align: left;">             return v.replace(&#34;sqlite://&#34;, &#34;sqlite+aiosqlite://&#34;, 1)</p><p style="text-align: left;">         return v</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"> settings = Settings()</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(3) Setup Database Connection (backend/app/database.py - NEW FILE)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/database.py</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession</p><p style="text-align: left;">from sqlalchemy.orm import sessionmaker, declarative_base</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;"></p><p style="text-align: left;"># Create async engine instance</p><p style="text-align: left;">engine = create_async_engine(</p><p style="text-align: left;">    settings.DATABASE_URL,</p><p style="text-align: left;">    echo=False, # Set to True to log SQL queries (useful for debugging)</p><p style="text-align: left;">    future=True # Use 2.0 style features</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Create sessionmaker</p><p style="text-align: left;"># expire_on_commit=False prevents attributes from expiring after commit</p><p style="text-align: left;">AsyncSessionLocal = sessionmaker(</p><p style="text-align: left;">    engine, class_=AsyncSession, expire_on_commit=False</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Base class for our models</p><p style="text-align: left;">Base = declarative_base()</p><p style="text-align: left;"></p><p style="text-align: left;"># Dependency to get DB session in API routes</p><p style="text-align: left;">async def get_db() -&#62; AsyncSession:</p><p style="text-align: left;">    async with AsyncSessionLocal() as session:</p><p style="text-align: left;">        try:</p><p style="text-align: left;">            yield session</p><p style="text-align: left;">            await session.commit() # Commit changes if no exceptions occurred</p><p style="text-align: left;">        except Exception:</p><p style="text-align: left;">            await session.rollback() # Rollback on error</p><p style="text-align: left;">            raise</p><p style="text-align: left;">        finally:</p><p style="text-align: left;">            await session.close() # Ensure session is closed</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(4) Define SQLAlchemy Models (backend/app/db_models.py - NEW FILE)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/db_models.py</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">from sqlalchemy import Column, String, DateTime, Text, ForeignKey, Integer, JSON, Float, Boolean</p><p style="text-align: left;">from sqlalchemy.dialects.postgresql import UUID # For PostgreSQL UUID type</p><p style="text-align: left;">from sqlalchemy.orm import relationship</p><p style="text-align: left;">from sqlalchemy.sql import func # For default timestamps</p><p style="text-align: left;">from .database import Base</p><p style="text-align: left;"></p><p style="text-align: left;">class User(Base): # Placeholder for fastapi-users later</p><p style="text-align: left;">    __tablename__ = &#34;users&#34;</p><p style="text-align: left;">    # Use Integer for simpler local testing, switch to UUID later if needed</p><p style="text-align: left;">    # id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)</p><p style="text-align: left;">    id = Column(Integer, primary_key=True, index=True)</p><p style="text-align: left;">    email = Column(String, unique=True, index=True, nullable=False)</p><p style="text-align: left;">    hashed_password = Column(String, nullable=False)</p><p style="text-align: left;">    is_active = Column(Boolean, default=True)</p><p style="text-align: left;">    is_superuser = Column(Boolean, default=False) # Example field for auth roles</p><p style="text-align: left;">    # Relationships (will link to tasks, results etc.)</p><p style="text-align: left;">    tasks = relationship(&#34;TaskRecord&#34;, back_populates=&#34;owner&#34;, lazy=&#34;selectin&#34;) # Eager load owner tasks</p><p style="text-align: left;"></p><p style="text-align: left;">class TaskRecord(Base):</p><p style="text-align: left;">    __tablename__ = &#34;task_records&#34;</p><p style="text-align: left;">    id = Column(String, primary_key=True, index=True) # Use Celery Task ID as primary key</p><p style="text-align: left;">    celery_task_id = Column(String, unique=True, index=True, nullable=False) # Redundant? Maybe use id from celery directly</p><p style="text-align: left;">    user_id = Column(Integer, ForeignKey(&#34;users.id&#34;), nullable=True, index=True) # Link to user, nullable if tasks can be anonymous initially</p><p style="text-align: left;">    task_type = Column(String, index=True, nullable=False) # e.g., &#39;summarization&#39;, &#39;image_generation&#39;</p><p style="text-align: left;">    status = Column(String, default=&#34;PENDING&#34;, index=True, nullable=False) # PENDING, PROCESSING, SUCCESS, FAILURE</p><p style="text-align: left;">    created_at = Column(DateTime(timezone=True), server_default=func.now())</p><p style="text-align: left;">    updated_at = Column(DateTime(timezone=True), onupdate=func.now())</p><p style="text-align: left;">    input_payload = Column(JSON, nullable=True) # Store the request payload</p><p style="text-align: left;">    result = Column(JSON, nullable=True) # Store the actual result (or reference)</p><p style="text-align: left;">    error_message = Column(Text, nullable=True) # Store error if status is FAILURE</p><p style="text-align: left;"></p><p style="text-align: left;">    owner = relationship(&#34;User&#34;, back_populates=&#34;tasks&#34;) # Relationship to User</p><p style="text-align: left;">    saved_result = relationship(&#34;SavedResult&#34;, back_populates=&#34;task&#34;, uselist=False) # One-to-one with SavedResult</p><p style="text-align: left;"></p><p style="text-align: left;">class SavedResult(Base): # Example for letting users save specific results</p><p style="text-align: left;">    __tablename__ = &#34;saved_results&#34;</p><p style="text-align: left;">    id = Column(Integer, primary_key=True, index=True)</p><p style="text-align: left;">    user_id = Column(Integer, ForeignKey(&#34;users.id&#34;), nullable=False, index=True)</p><p style="text-align: left;">    task_id = Column(String, ForeignKey(&#34;task_records.id&#34;), unique=True, nullable=False, index=True) # Ensure one save per task</p><p style="text-align: left;">    saved_at = Column(DateTime(timezone=True), server_default=func.now())</p><p style="text-align: left;">    custom_name = Column(String, nullable=True) # User can name the saved result</p><p style="text-align: left;"></p><p style="text-align: left;">    # Assuming result is stored in TaskRecord, link back to it</p><p style="text-align: left;">    task = relationship(&#34;TaskRecord&#34;, back_populates=&#34;saved_result&#34;)</p><p style="text-align: left;">    user = relationship(&#34;User&#34;) # Link back to user</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Note: Using Celery Task ID as the primary key for TaskRecord simplifies lookup.</p><p style="text-align: left;"></p><p style="text-align: left;">(5) Setup Database Migrations (Alembic)</p><p style="text-align: left;"></p><p style="text-align: left;">In the backend/ directory, run: alembic init alembic</p><p style="text-align: left;">This creates an alembic directory and an alembic.ini file.</p><p style="text-align: left;">Edit alembic/env.py:</p><p style="text-align: left;">Near the top, add:</p><p style="text-align: left;">from app.db_models import Base # Import your models&#39; Base</p><p style="text-align: left;">from app.config import settings # Import settings for DB URL</p><p style="text-align: left;">import asyncio # Import asyncio</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import create_async_engine # Import async engine</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Find the target_metadata = None line and change it to:</p><p style="text-align: left;">target_metadata = Base.metadata</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Modify the run_migrations_offline() function (or add if missing, check template):</p><p style="text-align: left;">def run_migrations_offline() -&#62; None:</p><p style="text-align: left;">    &#34;&#34;&#34;Run migrations in &#39;offline&#39; mode.&#34;&#34;&#34;</p><p style="text-align: left;">    url = settings.DATABASE_URL # Use URL from settings</p><p style="text-align: left;">    context.configure(</p><p style="text-align: left;">        url=str(url).replace(&#39;+asyncpg&#39;,&#39;&#39;).replace(&#39;+aiosqlite&#39;,&#39;&#39;), # Alembic needs sync URL format</p><p style="text-align: left;">        target_metadata=target_metadata,</p><p style="text-align: left;">        literal_binds=True,</p><p style="text-align: left;">        dialect_opts={&#34;paramstyle&#34;: &#34;named&#34;},</p><p style="text-align: left;">    )</p><p style="text-align: left;">    with context.begin_transaction():</p><p style="text-align: left;">        context.run_migrations()</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Modify the run_migrations_online() function (or replace its core logic):</p><p style="text-align: left;"># Replace the existing run_migrations_online or add this async version</p><p style="text-align: left;">async def run_async_migrations() -&#62; None:</p><p style="text-align: left;">    &#34;&#34;&#34;Run migrations in &#39;online&#39; mode using async engine.&#34;&#34;&#34;</p><p style="text-align: left;">    connectable = create_async_engine(settings.DATABASE_URL, future=True)</p><p style="text-align: left;"></p><p style="text-align: left;">    async with connectable.connect() as connection:</p><p style="text-align: left;">        await connection.run_sync(</p><p style="text-align: left;">            do_run_migrations,</p><p style="text-align: left;">            # Pass context config options</p><p style="text-align: left;">            context_opts={</p><p style="text-align: left;">                &#34;version_table_schema&#34;: target_metadata.schema,</p><p style="text-align: left;">                &#34;include_schemas&#34;: True,</p><p style="text-align: left;">                &#34;target_metadata&#34;: target_metadata,</p><p style="text-align: left;">                # Add other options if needed</p><p style="text-align: left;">            }</p><p style="text-align: left;">        )</p><p style="text-align: left;">    await connectable.dispose()</p><p style="text-align: left;"></p><p style="text-align: left;">def do_run_migrations(connection, context_opts):</p><p style="text-align: left;">     context.configure(connection=connection, **context_opts)</p><p style="text-align: left;">     with context.begin_transaction():</p><p style="text-align: left;">          context.run_migrations()</p><p style="text-align: left;"></p><p style="text-align: left;">def run_migrations_online() -&#62; None:</p><p style="text-align: left;">    &#34;&#34;&#34;Entry point for &#39;online&#39; mode.&#34;&#34;&#34;</p><p style="text-align: left;">    asyncio.run(run_async_migrations())</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Edit alembic.ini:</p><p style="text-align: left;">Find the sqlalchemy.url line and set it using the environment variable:</p><p style="text-align: left;">sqlalchemy.url = %(DB_URL)s</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Ini</p><p style="text-align: left;">Ensure you pass the environment variable when running alembic, e.g., DB_URL=$(grep DATABASE_URL .env | cut -d &#39;=&#39; -f2) alembic upgrade head or set it in your shell.</p><p style="text-align: left;">Create Initial Migration:</p><p style="text-align: left;">Run: alembic revision --autogenerate -m &#34;Initial migration with User, TaskRecord, SavedResult tables&#34;</p><p style="text-align: left;">Check the generated script in alembic/versions/.</p><p style="text-align: left;">Apply Migration:</p><p style="text-align: left;">Run: alembic upgrade head (Make sure your database server is running and the DB exists!)</p><p style="text-align: left;">(6) Update Backend Logic to Use Database</p><p style="text-align: left;"></p><p style="text-align: left;">Refactor tasks.py, services.py, and api.py to interact with the database.</p><p style="text-align: left;"></p><p style="text-align: left;">(a) backend/app/crud.py (NEW FILE - Database operations)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/crud.py</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession</p><p style="text-align: left;">from sqlalchemy.future import select</p><p style="text-align: left;">from sqlalchemy import update, delete</p><p style="text-align: left;">from typing import Optional, Dict, Any, List</p><p style="text-align: left;">import uuid # For generating TaskRecord ID if not using celery ID</p><p style="text-align: left;"></p><p style="text-align: left;">from . import db_models as models # Use db_models alias</p><p style="text-align: left;"></p><p style="text-align: left;">async def create_task_record(db: AsyncSession, celery_task_id: str, task_type: str, input_payload: Optional[Dict[str, Any]] = None, user_id: Optional[int] = None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    &#34;&#34;&#34;Creates a new task record in the database.&#34;&#34;&#34;</p><p style="text-align: left;">    # Using celery_task_id also as the primary key for simplicity here</p><p style="text-align: left;">    db_task = models.TaskRecord(</p><p style="text-align: left;">        id=celery_task_id, </p><p style="text-align: left;">        celery_task_id=celery_task_id,</p><p style="text-align: left;">        user_id=user_id,</p><p style="text-align: left;">        task_type=task_type,</p><p style="text-align: left;">        status=&#34;PENDING&#34;, # Initial status before worker picks it up</p><p style="text-align: left;">        input_payload=input_payload</p><p style="text-align: left;">    )</p><p style="text-align: left;">    db.add(db_task)</p><p style="text-align: left;">    await db.flush() # Assigns ID and makes it available before commit</p><p style="text-align: left;">    # await db.refresh(db_task) # Refresh might not be needed immediately after flush</p><p style="text-align: left;">    print(f&#34;DB TaskRecord created: {db_task.id}&#34;)</p><p style="text-align: left;">    return db_task</p><p style="text-align: left;"></p><p style="text-align: left;">async def update_task_status(db: AsyncSession, task_id: str, status: str, result: Optional[Dict[str, Any]] = None, error_message: Optional[str] = None) -&#62; Optional[models.TaskRecord]:</p><p style="text-align: left;">    &#34;&#34;&#34;Updates the status, result, or error of a task record.&#34;&#34;&#34;</p><p style="text-align: left;">    print(f&#34;Updating DB TaskRecord {task_id}: Status={status}&#34;)</p><p style="text-align: left;">    stmt = (</p><p style="text-align: left;">        update(models.TaskRecord)</p><p style="text-align: left;">        .where(models.TaskRecord.id == task_id)</p><p style="text-align: left;">        .values(status=status, result=result, error_message=error_message)</p><p style="text-align: left;">        .execution_options(synchronize_session=&#34;fetch&#34;) # Or False if not needed</p><p style="text-align: left;">    )</p><p style="text-align: left;">    result_proxy = await db.execute(stmt)</p><p style="text-align: left;">    </p><p style="text-align: left;">    if result_proxy.rowcount == 0:</p><p style="text-align: left;">        print(f&#34;DB TaskRecord {task_id} not found for update.&#34;)</p><p style="text-align: left;">        return None</p><p style="text-align: left;"></p><p style="text-align: left;">    # Fetch the updated record to return it (optional, but good practice)</p><p style="text-align: left;">    # You could also use .returning(models.TaskRecord) in the update stmt if DB supports it</p><p style="text-align: left;">    updated_task = await get_task_record(db, task_id)</p><p style="text-align: left;">    return updated_task</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">async def get_task_record(db: AsyncSession, task_id: str) -&#62; Optional[models.TaskRecord]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets a task record by its ID.&#34;&#34;&#34;</p><p style="text-align: left;">    stmt = select(models.TaskRecord).where(models.TaskRecord.id == task_id)</p><p style="text-align: left;">    result = await db.execute(stmt)</p><p style="text-align: left;">    return result.scalar_one_or_none()</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add CRUD functions for SavedResult (create, get_by_user, delete)</p><p style="text-align: left;"># TODO: Add CRUD functions for User (needed for Auth) - fastapi-users handles much of this</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(b) backend/app/tasks.py (Refactored Celery Task)</p><p style="text-align: left;"></p><p style="text-align: left;">Update the Celery task to interact with the database.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/tasks.py</p><p style="text-align: left;">import requests</p><p style="text-align: left;">import os</p><p style="text-align: left;">import base64</p><p style="text-align: left;">import time</p><p style="text-align: left;">from celery import shared_task</p><p style="text-align: left;">from celery.result import AsyncResult</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession # Import async session</p><p style="text-align: left;">from typing import Dict, Any, Optional</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .database import AsyncSessionLocal # Import session factory</p><p style="text-align: left;">from . import crud # Import CRUD functions</p><p style="text-align: left;"></p><p style="text-align: left;"># _make_hf_request helper remains the same...</p><p style="text-align: left;"># ... (keep the _make_hf_request function from previous step) ...</p><p style="text-align: left;"></p><p style="text-align: left;">def _make_hf_request(model_id: str, payload: Dict[str, Any], is_image_output: bool = False, is_audio_output: bool = False) -&#62; Dict[str, Any]:</p><p style="text-align: left;">    &#34;&#34;&#34;Internal helper to make the actual HF API request and handle response types.&#34;&#34;&#34;</p><p style="text-align: left;">    api_url = f&#34;{settings.HF_API_BASE_URL}{model_id}&#34;</p><p style="text-align: left;">    result_payload = {}</p><p style="text-align: left;">    error_payload = None</p><p style="text-align: left;">    print(f&#34;Making HF API call to: {api_url}&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Pass necessary headers (ensure token is loaded)</p><p style="text-align: left;">        HEADERS = {&#34;Authorization&#34;: f&#34;Bearer {settings.HF_API_TOKEN}&#34;}</p><p style="text-align: left;">        # Handle potential non-JSON payload for transcription</p><p style="text-align: left;">        request_kwargs = {&#39;headers&#39;: HEADERS, &#39;timeout&#39;: 300}</p><p style="text-align: left;">        if task_type == &#34;transcription&#34; and isinstance(payload, bytes): # Check if raw bytes passed</p><p style="text-align: left;">             request_kwargs[&#39;data&#39;] = payload</p><p style="text-align: left;">             # Need to ensure Content-Type is set correctly if not inferred by requests</p><p style="text-align: left;">             # request_kwargs[&#39;headers&#39;][&#39;Content-Type&#39;] = &#39;application/octet-stream&#39; # Or appropriate type</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            request_kwargs[&#39;json&#39;] = payload</p><p style="text-align: left;"></p><p style="text-align: left;">        response = requests.post(api_url, **request_kwargs)</p><p style="text-align: left;"></p><p style="text-align: left;">        content_type = response.headers.get(&#39;Content-Type&#39;, &#39;&#39;)</p><p style="text-align: left;"></p><p style="text-align: left;">        if response.status_code == 503: # Model loading</p><p style="text-align: left;">            error_payload = f&#34;Model {model_id} is loading (503), please try again later.&#34;</p><p style="text-align: left;">            raise ValueError(error_payload)</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_image_output and content_type.startswith(&#39;image/&#39;):</p><p style="text-align: left;">            if response.ok:</p><p style="text-align: left;">                image_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;image_base64&#34;: image_base64}</p><p style="text-align: left;">            else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for image: {response.text}&#34;</p><p style="text-align: left;">                raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;"></p><p style="text-align: left;">        elif is_audio_output and content_type.startswith(&#39;audio/&#39;):</p><p style="text-align: left;">             if response.ok:</p><p style="text-align: left;">                audio_base64 = base64.b64encode(response.content).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">                result_payload = {&#34;audio_base64&#34;: audio_base64} </p><p style="text-align: left;">             else:</p><p style="text-align: left;">                error_payload = f&#34;API Error {response.status_code} for audio: {response.text}&#34;</p><p style="text-align: left;">                raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;">        </p><p style="text-align: left;">        elif content_type.startswith(&#39;application/json&#39;) or response.ok: </p><p style="text-align: left;">            try:</p><p style="text-align: left;">                result_data = response.json()</p><p style="text-align: left;">                response.raise_for_status() </p><p style="text-align: left;">                if isinstance(result_data, list) and result_data:</p><p style="text-align: left;">                    # Specific parsing for known list-based results</p><p style="text-align: left;">                    if model_id == settings.MODEL_SENTIMENT:</p><p style="text-align: left;">                         result_payload = {&#34;sentiment&#34;: result_data[0]} # Wrap list in dict</p><p style="text-align: left;">                    elif model_id == settings.MODEL_NER:</p><p style="text-align: left;">                         result_payload = {&#34;entities&#34;: result_data} # NER often returns list directly</p><p style="text-align: left;">                    else:</p><p style="text-align: left;">                         result_payload = result_data[0] # General case</p><p style="text-align: left;">                elif isinstance(result_data, dict):</p><p style="text-align: left;">                     result_payload = result_data </p><p style="text-align: left;">                else:</p><p style="text-align: left;">                     result_payload = {&#34;raw_response&#34;: result_data} </p><p style="text-align: left;"></p><p style="text-align: left;">            except requests.exceptions.JSONDecodeError:</p><p style="text-align: left;">                 if response.ok:</p><p style="text-align: left;">                     error_payload = f&#34;Received non-JSON success ({response.status_code}). Body: {response.text[:100]}...&#34;</p><p style="text-align: left;">                     raise ValueError(error_payload) </p><p style="text-align: left;">                 else: </p><p style="text-align: left;">                     error_payload = f&#34;API Error {response.status_code}: {response.text}&#34;</p><p style="text-align: left;">                     raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;">            except requests.exceptions.HTTPError as e:</p><p style="text-align: left;">                 error_payload = f&#34;API HTTP Error {response.status_code}: {e}. Response: {result_data}&#34;</p><p style="text-align: left;">                 raise e </p><p style="text-align: left;">        else: </p><p style="text-align: left;">            error_payload = f&#34;Unhandled API Error {response.status_code} (Content-Type: {content_type}): {response.text}&#34;</p><p style="text-align: left;">            raise requests.exceptions.HTTPError(error_payload, response=response)</p><p style="text-align: left;"></p><p style="text-align: left;">    except requests.exceptions.Timeout:</p><p style="text-align: left;">         error_payload = f&#34;API Request timed out for {model_id}&#34;</p><p style="text-align: left;">         raise TimeoutError(error_payload) </p><p style="text-align: left;">    except requests.exceptions.RequestException as e:</p><p style="text-align: left;">        error_payload = f&#34;API Request failed for {model_id}: {e}&#34;</p><p style="text-align: left;">        raise e </p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        error_payload = f&#34;Unexpected error during API call for {model_id}: {type(e).__name__} - {e}&#34;</p><p style="text-align: left;">        raise e </p><p style="text-align: left;"></p><p style="text-align: left;">    return result_payload</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@shared_task(bind=True, max_retries=3, default_retry_delay=10) # Add retry delay</p><p style="text-align: left;">async def celery_hf_inference_task(self, task_record_id: str, model_id: str, payload: Dict[str, Any], task_type: str):</p><p style="text-align: left;">    &#34;&#34;&#34;Celery task interacting with DB.&#34;&#34;&#34;</p><p style="text-align: left;">    print(f&#34;Celery task {self.request.id} (DB Record: {task_record_id}, Type: {task_type}) started for model {model_id}&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    async with AsyncSessionLocal() as db: # Get async session</p><p style="text-align: left;">        try:</p><p style="text-align: left;">            # Mark task as PROCESSING in DB</p><p style="text-align: left;">            await crud.update_task_status(db, task_record_id, status=&#34;PROCESSING&#34;)</p><p style="text-align: left;">            await db.commit() # Commit status update immediately</p><p style="text-align: left;"></p><p style="text-align: left;">            is_image = task_type == &#34;image_generation&#34;</p><p style="text-align: left;">            # Adjust audio detection based on how TTS vs Transcription models respond</p><p style="text-align: left;">            is_audio_output = task_type == &#34;tts&#34; </p><p style="text-align: left;">            # Transcription input payload might need special handling if passing bytes</p><p style="text-align: left;">            input_payload_for_api = payload</p><p style="text-align: left;">            if task_type == &#34;transcription&#34; and &#39;audio_b64&#39; in payload:</p><p style="text-align: left;">                 # Decode base64 before potentially passing raw bytes</p><p style="text-align: left;">                 # This part HIGHLY depends on the target API and how _make_hf_request handles &#39;data&#39;</p><p style="text-align: left;">                 try:</p><p style="text-align: left;">                     audio_bytes = base64.b64decode(payload[&#39;audio_b64&#39;])</p><p style="text-align: left;">                     input_payload_for_api = audio_bytes # Pass raw bytes</p><p style="text-align: left;">                     print(f&#34;Decoded {len(audio_bytes)} bytes for transcription task {task_record_id}&#34;)</p><p style="text-align: left;">                 except Exception as decode_err:</p><p style="text-align: left;">                      raise ValueError(f&#34;Failed to decode audio data for transcription: {decode_err}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">            # Run the actual inference via helper</p><p style="text-align: left;">            # Make sure _make_hf_request can handle bytes if needed</p><p style="text-align: left;">            result = _make_hf_request(model_id, input_payload_for_api, is_image_output=is_image, is_audio_output=is_audio_output)</p><p style="text-align: left;"></p><p style="text-align: left;">            # Check if the helper returned an error structure</p><p style="text-align: left;">            if isinstance(result, dict) and &#34;error&#34; in result:</p><p style="text-align: left;">                 raise ValueError(f&#34;HF Request Helper returned error: {result[&#39;error&#39;]}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">            # Update DB with SUCCESS and the result</p><p style="text-align: left;">            await crud.update_task_status(db, task_record_id, status=&#34;SUCCESS&#34;, result=result)</p><p style="text-align: left;">            await db.commit()</p><p style="text-align: left;">            print(f&#34;Celery task {self.request.id} (DB: {task_record_id}) completed successfully.&#34;)</p><p style="text-align: left;">            return result # Return result for Celery backend</p><p style="text-align: left;"></p><p style="text-align: left;">        except Exception as exc:</p><p style="text-align: left;">            print(f&#34;Celery task {self.request.id} (DB: {task_record_id}) failed: {exc}&#34;)</p><p style="text-align: left;">            error_msg = str(exc)</p><p style="text-align: left;">            # Update DB with FAILURE and error message</p><p style="text-align: left;">            try:</p><p style="text-align: left;">                 # Try to update DB even if task failed</p><p style="text-align: left;">                 await crud.update_task_status(db, task_record_id, status=&#34;FAILURE&#34;, error_message=error_msg[:1000]) # Limit error message length</p><p style="text-align: left;">                 await db.commit()</p><p style="text-align: left;">            except Exception as db_err:</p><p style="text-align: left;">                 print(f&#34;CRITICAL: Failed to update task {task_record_id} status to FAILURE in DB: {db_err}&#34;)</p><p style="text-align: left;">                 await db.rollback() # Rollback the failed update attempt</p><p style="text-align: left;"></p><p style="text-align: left;">            # Re-raise for Celery retry/failure handling</p><p style="text-align: left;">            # Use self.retry to trigger Celery&#39;s retry mechanism</p><p style="text-align: left;">            try:</p><p style="text-align: left;">                self.retry(exc=exc, countdown=int(default_retry_delay * (2 ** self.request.retries)))</p><p style="text-align: left;">            except self.MaxRetriesExceededError:</p><p style="text-align: left;">                 print(f&#34;Task {self.request.id} (DB: {task_record_id}) exceeded max retries.&#34;)</p><p style="text-align: left;">                 # Final failure state is already set in DB hopefully</p><p style="text-align: left;">                 # Let Celery mark task as failed in backend</p><p style="text-align: left;">                 raise exc # Raise final exception</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># Celery status check function (not strictly needed if API uses DB, but can be useful)</p><p style="text-align: left;">def get_celery_task_status_direct(task_id: str) -&#62; Dict[str, Any]:</p><p style="text-align: left;">     &#34;&#34;&#34;Gets status and result DIRECTLY from the Celery backend (Redis).&#34;&#34;&#34;</p><p style="text-align: left;">     # ... (Implementation similar to tasks.get_celery_task_status from previous step) ...</p><p style="text-align: left;">     # This is less critical now as the primary source of truth should be the database.</p><p style="text-align: left;">     task_result = AsyncResult(task_id) </p><p style="text-align: left;">     status = task_result.status</p><p style="text-align: left;">     result_data = None</p><p style="text-align: left;">     error_info = None</p><p style="text-align: left;">     if task_result.successful(): status = &#34;SUCCESS&#34;; result_data = {&#34;result_data&#34;: task_result.result}</p><p style="text-align: left;">     elif task_result.failed(): status = &#34;FAILURE&#34;; error_info = str(task_result.info)</p><p style="text-align: left;">     elif status in [&#39;PENDING&#39;, &#39;STARTED&#39;, &#39;RETRY&#39;]: status = &#34;PROCESSING&#34; # Map to PROCESSING</p><p style="text-align: left;">     </p><p style="text-align: left;">     return {&#34;task_id&#34;: task_id, &#34;status&#34;: status, &#34;result&#34;: result_data, &#34;error&#34;: error_info }</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(c) backend/app/services.py (Refactored Service Layer)</p><p style="text-align: left;"></p><p style="text-align: left;">Update the service layer to create DB records first, then dispatch Celery tasks using the DB record ID. The status check should now primarily consult the DB.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/services.py</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">import base64</p><p style="text-align: left;">from fastapi import HTTPException, Depends</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession # Import async session</p><p style="text-align: left;">from typing import Dict, Any, Optional, List</p><p style="text-align: left;">from . import tasks # Import task definitions</p><p style="text-align: left;">from . import crud # Import CRUD operations</p><p style="text-align: left;">from . import db_models # Import DB models</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .celery_app import celery_app # Import Celery app instance</p><p style="text-align: left;">from .database import get_db # Import DB session dependency</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Task Submission Service Functions ---</p><p style="text-align: left;"></p><p style="text-align: left;">async def _dispatch_celery_task(</p><p style="text-align: left;">    db: AsyncSession,</p><p style="text-align: left;">    model_id: str,</p><p style="text-align: left;">    payload: Dict[str, Any],</p><p style="text-align: left;">    task_type: str,</p><p style="text-align: left;">    user_id: Optional[int] = None # TODO: Get from authenticated user</p><p style="text-align: left;">) -&#62; models.TaskRecord:</p><p style="text-align: left;">    &#34;&#34;&#34;Creates DB record and dispatches task to Celery.&#34;&#34;&#34;</p><p style="text-align: left;">    # Create a placeholder ID for the DB record (Celery ID comes later)</p><p style="text-align: left;">    # Or potentially generate Celery ID first if possible/needed</p><p style="text-align: left;">    temp_task_id = str(uuid.uuid4()) </p><p style="text-align: left;">    db_task_record = None</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        # Create DB record with PENDING status (worker will update to PROCESSING)</p><p style="text-align: left;">        db_task_record = await crud.create_task_record(</p><p style="text-align: left;">            db, </p><p style="text-align: left;">            celery_task_id=temp_task_id, # Use temporary UUID initially</p><p style="text-align: left;">            task_type=task_type, </p><p style="text-align: left;">            input_payload=payload, </p><p style="text-align: left;">            user_id=user_id</p><p style="text-align: left;">        )</p><p style="text-align: left;">        # Important: Commit the DB transaction to get the record saved BEFORE dispatching</p><p style="text-align: left;">        # The get_db dependency now handles commit/rollback</p><p style="text-align: left;">        # await db.commit() # Commit handled by get_db dependency exit</p><p style="text-align: left;"></p><p style="text-align: left;">        # Dispatch to Celery, passing the DB task record ID</p><p style="text-align: left;">        celery_task = tasks.celery_hf_inference_task.delay(</p><p style="text-align: left;">            task_record_id=db_task_record.id, # Pass the DB ID to the worker</p><p style="text-align: left;">            model_id=model_id,</p><p style="text-align: left;">            payload=payload, # Pass original payload</p><p style="text-align: left;">            task_type=task_type</p><p style="text-align: left;">        )</p><p style="text-align: left;"></p><p style="text-align: left;">        # Update the DB record with the actual Celery task ID</p><p style="text-align: left;">        db_task_record.celery_task_id = celery_task.id</p><p style="text-align: left;">        db_task_record.status = &#34;SUBMITTED&#34; # Indicate dispatched</p><p style="text-align: left;">        await db.flush() # Update the record with celery ID</p><p style="text-align: left;"></p><p style="text-align: left;">        print(f&#34;Task {db_task_record.id} (Celery ID: {celery_task.id}) dispatched.&#34;)</p><p style="text-align: left;">        return db_task_record</p><p style="text-align: left;"></p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;ERROR dispatching Celery task or creating DB record: {e}&#34;)</p><p style="text-align: left;">        # Rollback handled by get_db dependency on exception</p><p style="text-align: left;">        # If db_task_record was created, maybe mark it as FAILED_DISPATCH?</p><p style="text-align: left;">        # if db_task_record:</p><p style="text-align: left;">        #    try:</p><p style="text-align: left;">        #        db_task_record.status = &#34;FAILED_DISPATCH&#34;</p><p style="text-align: left;">        #        db_task_record.error_message = str(e)</p><p style="text-align: left;">        #        await db.commit()</p><p style="text-align: left;">        #    except: pass # Avoid nested exceptions hiding original</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to submit task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">async def get_task_status_info_db(db: AsyncSession, task_id: str) -&#62; Optional[models.TaskRecord]:</p><p style="text-align: left;">    &#34;&#34;&#34;Gets status primarily from the database.&#34;&#34;&#34;</p><p style="text-align: left;">    # Task ID here should be the DB TaskRecord ID (which we used Celery ID for)</p><p style="text-align: left;">    db_task = await crud.get_task_record(db, task_id)</p><p style="text-align: left;">    if not db_task:</p><p style="text-align: left;">        raise HTTPException(status_code=404, detail=f&#34;Task ID &#39;{task_id}&#39; not found.&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    # Optional: If status is still PENDING/SUBMITTED/PROCESSING in DB, </p><p style="text-align: left;">    # you *could* double-check the Celery backend state, but DB should be updated by worker.</p><p style="text-align: left;">    # if db_task.status in [&#34;PENDING&#34;, &#34;SUBMITTED&#34;, &#34;PROCESSING&#34;]:</p><p style="text-align: left;">    #     celery_status_info = tasks.get_celery_task_status_direct(db_task.celery_task_id)</p><p style="text-align: left;">    #     # Potentially update DB if Celery reports final state but DB is lagging? Complex.</p><p style="text-align: left;">    #     # print(f&#34;DB status for {task_id} is {db_task.status}, Celery reports {celery_status_info[&#39;status&#39;]}&#34;)</p><p style="text-align: left;">    </p><p style="text-align: left;">    return db_task</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Specific Task Starters (Updated to use DB+Celery dispatcher) ---</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_summarization(db: AsyncSession, text: str, min_len: int, max_len: int, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;min_length&#34;: min_len, &#34;max_length&#34;: max_len}}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_SUMMARIZATION, payload, &#34;summarization&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_translation(db: AsyncSession, text: str, source_lang: Optional[str], target_lang: str, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    model_id = f&#34;{settings.MODEL_TRANSLATION_PREFIX}{source_lang or &#39;en&#39;}-{target_lang}&#34;</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, model_id, payload, &#34;translation&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_image_generation(db: AsyncSession, prompt: str, negative_prompt: Optional[str], user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt}</p><p style="text-align: left;">    if negative_prompt:</p><p style="text-align: left;">        payload[&#34;parameters&#34;] = {&#34;negative_prompt&#34;: negative_prompt}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_IMAGE_GEN, payload, &#34;image_generation&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_doc_qa(db: AsyncSession, context: str, question: str, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: {&#34;question&#34;: question, &#34;context&#34;: context}}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_DOC_QA, payload, &#34;question_answering&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_transcription(db: AsyncSession, audio_bytes: bytes, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    # Encode bytes to pass via JSON to Celery task</p><p style="text-align: left;">    audio_b64 = base64.b64encode(audio_bytes).decode(&#39;utf-8&#39;)</p><p style="text-align: left;">    payload = {&#34;audio_b64&#34;: audio_b64} # Task needs to decode this</p><p style="text-align: left;">    print(f&#34;Dispatching transcription, payload size hint (b64): {len(audio_b64)}&#34;)</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_TRANSCRIPTION, payload, &#34;transcription&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_tts(db: AsyncSession, text: str, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_TTS, payload, &#34;tts&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_code_generation(db: AsyncSession, prompt: str, language: str, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: prompt, &#34;parameters&#34;: {&#34;return_full_text&#34;: False}}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_CODE_GEN, payload, &#34;code_generation&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_zero_shot(db: AsyncSession, text: str, labels: List[str], user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text, &#34;parameters&#34;: {&#34;candidate_labels&#34;: labels}}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_ZERO_SHOT, payload, &#34;zero_shot&#34;, user_id)</p><p style="text-align: left;"></p><p style="text-align: left;">async def start_ner(db: AsyncSession, text: str, user_id: Optional[int]=None) -&#62; models.TaskRecord:</p><p style="text-align: left;">    payload = {&#34;inputs&#34;: text}</p><p style="text-align: left;">    return await _dispatch_celery_task(db, settings.MODEL_NER, payload, &#34;ner&#34;, user_id)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(d) backend/app/api.py (Refactored API Layer)</p><p style="text-align: left;"></p><p style="text-align: left;">Update API endpoints to use the new DB-aware service functions and the get_db dependency.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/api.py</p><p style="text-align: left;">from fastapi import APIRouter, HTTPException, Depends, UploadFile, File</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession # Import async session</p><p style="text-align: left;">from typing import List, Optional</p><p style="text-align: left;">from . import models</p><p style="text-align: left;">from . import services</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .database import get_db # Import DB session dependency</p><p style="text-align: left;"># TODO: Add authentication dependencies later</p><p style="text-align: left;"># from .auth import get_current_active_user </p><p style="text-align: left;"># from .db_models import User as DBUser # Use DB model alias</p><p style="text-align: left;"></p><p style="text-align: left;">router = APIRouter()</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Helper Function for Parsing Task Results (from DB model) ---</p><p style="text-align: left;">def _parse_db_task_result(db_task: models.db_models.TaskRecord) -&#62; Optional[models.TaskResult]:</p><p style="text-align: left;">    if db_task.status == &#34;SUCCESS&#34; and db_task.result:</p><p style="text-align: left;">        raw_result = db_task.result # Result is already stored as JSON in DB</p><p style="text-align: left;">        task_type = db_task.task_type</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Use task_type hint from DB to parse correctly</p><p style="text-align: left;">        if isinstance(raw_result, dict):</p><p style="text-align: left;">             if task_type == &#34;summarization&#34; and &#34;summary_text&#34; in raw_result: return models.TaskResult(result_data=models.SummaryResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;translation&#34; and &#34;translation_text&#34; in raw_result: return models.TaskResult(result_data=models.TranslationResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;image_generation&#34; and &#34;image_base64&#34; in raw_result: return models.TaskResult(result_data=models.ImageGenResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;ner&#34; and &#34;entities&#34; in raw_result: return models.TaskResult(result_data=models.NerResult(entities=raw_result[&#39;entities&#39;])) # NER returns list directly sometimes</p><p style="text-align: left;">             if task_type == &#34;question_answering&#34; and &#34;answer&#34; in raw_result: return models.TaskResult(result_data=models.QAResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;zero_shot&#34; and &#34;labels&#34; in raw_result: return models.TaskResult(result_data=models.ZeroShotResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;code_generation&#34; and &#34;generated_text&#34; in raw_result: # Often key is &#39;generated_text&#39;</p><p style="text-align: left;">                   return models.TaskResult(result_data=models.CodeGenResult(generated_code=raw_result[&#39;generated_text&#39;]))</p><p style="text-align: left;">             if task_type == &#34;tts&#34; and &#34;audio_base64&#34; in raw_result: return models.TaskResult(result_data=models.TextToSpeechResult(**raw_result))</p><p style="text-align: left;">             if task_type == &#34;transcription&#34; and &#34;text&#34; in raw_result: # Whisper often returns &#39;text&#39; key</p><p style="text-align: left;">                 return models.TaskResult(result_data=models.TranscriptionResult(transcription_text=raw_result[&#39;text&#39;]))</p><p style="text-align: left;">             # Fallback for unparsed but successful dict results</p><p style="text-align: left;">             return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">        elif isinstance(raw_result, str): # Simple string result</p><p style="text-align: left;">             if task_type == &#34;transcription&#34;: # Assume string result means transcription text</p><p style="text-align: left;">                  return models.TaskResult(result_data=models.TranscriptionResult(transcription_text=raw_result))</p><p style="text-align: left;">             # Add more specific string checks if needed</p><p style="text-align: left;">             else:</p><p style="text-align: left;">                   return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">        else: # Other primitive types</p><p style="text-align: left;">              return models.TaskResult(result_data=raw_result)</p><p style="text-align: left;">    return None # Not SUCCESS or no result</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- API Endpoints (Using DB + Celery) ---</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/sentiment&#34;, response_model=models.SentimentResult, responses={500: {&#34;model&#34;: models.ErrorResponse}, 503: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def analyze_sentiment(data: models.TextInput, db: AsyncSession = Depends(get_db)): # Still synchronous, but could log task</p><p style="text-align: left;">    &#34;&#34;&#34;Analyzes sentiment using a suitable HF model (synchronous).&#34;&#34;&#34;</p><p style="text-align: left;">    # TODO: Optionally create a TaskRecord here even for sync tasks for unified history</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        result_payload = tasks._make_hf_request(settings.MODEL_SENTIMENT, {&#34;inputs&#34;: data.text}) # Direct call still possible</p><p style="text-align: left;">        if &#34;error&#34; in result_payload:</p><p style="text-align: left;">            detail = result_payload[&#39;error&#39;]</p><p style="text-align: left;">            status_code = 503 if &#34;loading&#34; in detail.lower() else 500</p><p style="text-align: left;">            raise HTTPException(status_code=status_code, detail=detail)</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Parsing logic adjusted for different possible sentiment model outputs</p><p style="text-align: left;">        scores = []</p><p style="text-align: left;">        if result_payload and isinstance(result_payload, list):</p><p style="text-align: left;">             # Handle case like [[{&#39;label&#39;: &#39;POSITIVE&#39;, &#39;score&#39;: 0.9}]]</p><p style="text-align: left;">             if result_payload[0] and isinstance(result_payload[0], list):</p><p style="text-align: left;">                 scores = [models.SentimentScore(**item) for item in result_payload[0]]</p><p style="text-align: left;">             # Handle case like [{&#39;label&#39;: &#39;POSITIVE&#39;, &#39;score&#39;: 0.9}]</p><p style="text-align: left;">             elif isinstance(result_payload[0], dict):</p><p style="text-align: left;">                  scores = [models.SentimentScore(**item) for item in result_payload]</p><p style="text-align: left;">        </p><p style="text-align: left;">        if scores:        </p><p style="text-align: left;">             return models.SentimentResult(sentiment=scores)</p><p style="text-align: left;">        else:</p><p style="text-align: left;">            print(f&#34;Unexpected sentiment response format: {result_payload}&#34;)</p><p style="text-align: left;">            raise HTTPException(status_code=500, detail=&#34;Could not parse sentiment response from HF API&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error in sentiment endpoint: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Internal server error: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/summarize&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def summarize_text(data: models.SummarizationRequest, db: AsyncSession = Depends(get_db)): # Add db dependency</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text summarization via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    # TODO: Get user_id from auth dependency later: current_user: DBUser = Depends(...)</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID when auth is added</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_summarization(db, data.text, data.min_length, data.max_length, user_id_placeholder)</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;) # Return DB task ID</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e # Re-raise service layer exceptions</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting summarization task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Failed to start summarization task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/translate&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def translate_text(data: models.TranslationRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for translation via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.target_lang or len(data.target_lang) &#60; 2:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Invalid target language code.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_translation(db, data.text, data.source_lang, data.target_lang, user_id_placeholder)</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting translation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start translation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-image&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_image(data: models.ImageGenRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for image generation via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.prompt:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Prompt cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_image_generation(db, data.prompt, data.negative_prompt, user_id_placeholder)</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting image generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start image generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/qa-document&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def qa_document(data: models.DocQARequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Document QA via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.context or not data.question:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Context and question cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_doc_qa(db, data.context, data.question, user_id_placeholder)</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting QA task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start QA task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/transcribe&#34;, response_model=models.TaskResponse, responses={400: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def transcribe_audio(file: UploadFile = File(...), db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for audio transcription via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not file.content_type.startswith(&#34;audio/&#34;):</p><p style="text-align: left;">         raise HTTPException(status_code=400, detail=&#34;Invalid file type. Please upload an audio file.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        audio_bytes = await file.read()</p><p style="text-align: left;">        if not audio_bytes:</p><p style="text-align: left;">             raise HTTPException(status_code=400, detail=&#34;Uploaded file is empty.&#34;)</p><p style="text-align: left;">        db_task = await services.start_transcription(db, audio_bytes, user_id_placeholder)</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting transcription task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to process file or start transcription task: {e}&#34;)</p><p style="text-align: left;">    finally:</p><p style="text-align: left;">        await file.close()</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/text-to-speech&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def text_to_speech(data: models.TextToSpeechRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for TTS via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_tts(db, data.text, user_id_placeholder)</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting TTS task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start TTS task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-code&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_code(data: models.CodeGenRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for code generation via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.prompt or not data.language:</p><p style="text-align: left;">        raise HTTPException(status_code=422, detail=&#34;Prompt and language are required.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_code_generation(db, data.prompt, data.language, user_id_placeholder)</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting code generation task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start code generation task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/classify-zero-shot&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def classify_zero_shot(data: models.ZeroShotRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for zero-shot classification via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.text or not data.candidate_labels:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text and candidate labels are required.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_zero_shot(db, data.text, data.candidate_labels, user_id_placeholder)</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">         print(f&#34;Error starting zero-shot classification task: {e}&#34;)</p><p style="text-align: left;">         raise HTTPException(status_code=500, detail=f&#34;Failed to start zero-shot classification task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/extract-entities&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def extract_entities(data: models.NerRequest, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for NER via Celery &#38; saves record.&#34;&#34;&#34;</p><p style="text-align: left;">    user_id_placeholder = None # Replace with actual user ID</p><p style="text-align: left;">    if not data.text:</p><p style="text-align: left;">         raise HTTPException(status_code=422, detail=&#34;Text cannot be empty.&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_ner(db, data.text, user_id_placeholder)</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error starting NER task: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=f&#34;Failed to start NER task: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- Central Task Status Endpoint (Now reads from DB) ---</p><p style="text-align: left;">@router.get(&#34;/api/task-status/{task_id}&#34;, response_model=models.TaskStatusResponse, responses={404: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def get_task_status_endpoint(task_id: str, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    &#34;&#34;&#34;Polls for the status and result of any background task from the database.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.get_task_status_info_db(db, task_id) # Use DB service</p><p style="text-align: left;">        if not db_task: # Should be handled by service, but double check</p><p style="text-align: left;">             raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">        # Parse the result stored in the DB record</p><p style="text-align: left;">        parsed_result = _parse_db_task_result(db_task)</p><p style="text-align: left;"></p><p style="text-align: left;">        return models.TaskStatusResponse(</p><p style="text-align: left;">             task_id=db_task.id,</p><p style="text-align: left;">             status=db_task.status,</p><p style="text-align: left;">             result=parsed_result,</p><p style="text-align: left;">             error=db_task.error_message</p><p style="text-align: left;">             )</p><p style="text-align: left;">    except HTTPException as e:</p><p style="text-align: left;">        raise e</p><p style="text-align: left;">    except Exception as e:</p><p style="text-align: left;">        print(f&#34;Error getting task status for {task_id} from DB: {e}&#34;)</p><p style="text-align: left;">        raise HTTPException(status_code=500, detail=&#34;Internal server error retrieving task status.&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"># --- TODO: Add History &#38; Saving Endpoints ---</p><p style="text-align: left;"># Example (Requires Authentication implemented first)</p><p style="text-align: left;"># @router.get(&#34;/api/history&#34;, response_model=List[models.TaskStatusResponse])</p><p style="text-align: left;"># async def get_user_history(db: AsyncSession = Depends(get_db), current_user: DBUser = Depends(get_current_active_user)):</p><p style="text-align: left;">#     # Fetch tasks for current_user.id from DB via CRUD function</p><p style="text-align: left;">#     # Parse results for each task</p><p style="text-align: left;">#     # Return list of TaskStatusResponse</p><p style="text-align: left;">#     pass</p><p style="text-align: left;"></p><p style="text-align: left;"># @router.post(&#34;/api/save/{task_id}&#34;, status_code=201)</p><p style="text-align: left;"># async def save_task_result(task_id: str, db: AsyncSession = Depends(get_db), current_user: DBUser = Depends(get_current_active_user)):</p><p style="text-align: left;">#      # Verify task_id belongs to current_user</p><p style="text-align: left;">#      # Create SavedResult entry in DB via CRUD function</p><p style="text-align: left;">#      pass</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(e) backend/app/main.py (Add DB startup/shutdown)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/main.py</p><p style="text-align: left;">from fastapi import FastAPI</p><p style="text-align: left;">from fastapi.middleware.cors import CORSMiddleware</p><p style="text-align: left;">from . import api</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .database import engine, Base # Import engine and Base for startup event</p><p style="text-align: left;"></p><p style="text-align: left;">app = FastAPI(</p><p style="text-align: left;">    title=&#34;NeuralBlitz Multi-Tool AI - v0.2 DB Integrated&#34;,</p><p style="text-align: left;">    description=&#34;Backend API with Celery tasks and DB persistence.&#34;,</p><p style="text-align: left;">    version=&#34;0.2.0&#34;</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Configure CORS</p><p style="text-align: left;"># TODO: Restrict origins in production!</p><p style="text-align: left;">origins = [&#34;http://localhost:3000&#34;, &#34;http://127.0.0.1:3000&#34;]</p><p style="text-align: left;">app.add_middleware(</p><p style="text-align: left;">    CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[&#34;*&#34;], allow_headers=[&#34;*&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Include the API router</p><p style="text-align: left;">app.include_router(api.router)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Add Database Startup Event ---</p><p style="text-align: left;"># This is not strictly needed if using Alembic externally, but good practice</p><p style="text-align: left;"># for some checks or initial data seeding if required. For now, it&#39;s commented</p><p style="text-align: left;"># as Alembic handles table creation.</p><p style="text-align: left;"># @app.on_event(&#34;startup&#34;)</p><p style="text-align: left;"># async def on_startup():</p><p style="text-align: left;">#     async with engine.begin() as conn:</p><p style="text-align: left;">#         # Optional: Use this if you weren&#39;t using Alembic</p><p style="text-align: left;">#         # await conn.run_sync(Base.metadata.create_all)</p><p style="text-align: left;">#         print(&#34;Database connection configured (tables should be created via Alembic).&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@app.get(&#34;/&#34;)</p><p style="text-align: left;">async def read_root():</p><p style="text-align: left;">    token_status = &#34;SET&#34; if settings.HF_API_TOKEN and settings.HF_API_TOKEN != &#34;YOUR_TOKEN_HERE&#34; else &#34;MISSING/INVALID&#34;</p><p style="text-align: left;">    db_status = &#34;Configured&#34; if settings.DATABASE_URL else &#34;Missing/Invalid URL&#34;</p><p style="text-align: left;">    return {</p><p style="text-align: left;">        &#34;message&#34;: &#34;Welcome to the NeuralBlitz AI Backend!&#34;,</p><p style="text-align: left;">        &#34;status&#34;: &#34;Operational&#34;,</p><p style="text-align: left;">        &#34;version&#34;: &#34;0.2.0&#34;,</p><p style="text-align: left;">        &#34;huggingface_token_status&#34;: token_status,</p><p style="text-align: left;">        &#34;database_status&#34;: db_status</p><p style="text-align: left;">    }</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(7) Frontend Changes</p><p style="text-align: left;"></p><p style="text-align: left;">No immediate changes are required in the frontend components (SentimentAnalyzer.js, ImageGenerator.js, the hook useTaskPolling.js) just because the backend switched to Celery and DB for persistence. The API endpoints they call (/api/... and /api/task-status/...) remain the same, and the response formats (TaskResponse, TaskStatusResponse) are designed to be consistent.</p><p style="text-align: left;">Important: The reliability of the background tasks is now much higher, and the status/results are persistent.</p><p style="text-align: left;">Future Work: You would now build the &#34;History&#34; page component, which would call new backend endpoints (that you still need to create) like /api/history to fetch tasks for the logged-in user from the database.</p><p style="text-align: left;">8. How to Run</p><p style="text-align: left;"></p><p style="text-align: left;">Start PostgreSQL: e.g., docker run -d -p 5432:5432 --name my-postgres -e POSTGRES_PASSWORD=mysecretpassword -e POSTGRES_DB=neuralblitz_db postgres</p><p style="text-align: left;">Setup Backend:</p><p style="text-align: left;">Navigate to backend/.</p><p style="text-align: left;">Ensure .env has the correct DATABASE_URL.</p><p style="text-align: left;">Activate venv: source venv/bin/activate or venv\Scripts\activate.</p><p style="text-align: left;">Install deps: pip install -r requirements.txt.</p><p style="text-align: left;">Run Migrations: alembic upgrade head (This creates the tables).</p><p style="text-align: left;">Run FastAPI app: uvicorn app.main:app --reload --port 8000</p><p style="text-align: left;">Start Redis: e.g., docker run -d -p 6379:6379 --name my-redis redis</p><p style="text-align: left;">Start Celery Worker: Open a separate terminal. Navigate to backend/, activate venv, run celery -A app.celery_app worker --loglevel=info -P solo (Using -P solo can sometimes help with debugging async code within celery tasks initially on Windows/macOS, remove for production concurrency).</p><p style="text-align: left;">Start Frontend: Navigate to frontend/, run npm start.</p><p style="text-align: left;">Summary of Progress:</p><p style="text-align: left;"></p><p style="text-align: left;">Celery + Redis integrated for robust background task processing.</p><p style="text-align: left;">PostgreSQL database integrated using SQLAlchemy async.</p><p style="text-align: left;">Database models created for Tasks (and basic User placeholder).</p><p style="text-align: left;">Alembic set up for database migrations.</p><p style="text-align: left;">Backend services refactored to create DB records before dispatching tasks and update DB on task completion.</p><p style="text-align: left;">Task status endpoint now retrieves state primarily from the database.</p><p style="text-align: left;">The application is now significantly more robust and persistent. The next logical step is User Authentication.</p><p style="text-align: left;">Okay, let&#39;s proceed with the next logical step: User Authentication. We&#39;ll use the fastapi-users library along with JWT for token-based authentication.</p><p style="text-align: left;"></p><p style="text-align: left;">Phase 2.3: Implement User Authentication (fastapi-users + JWT)</p><p style="text-align: left;"></p><p style="text-align: left;">(1) Update Backend Dependencies (backend/requirements.txt)</p><p style="text-align: left;"></p><p style="text-align: left;">Add fastapi-users with its SQLAlchemy backend and JWT support, plus python-jose for JWT handling and passlib for hashing.</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi</p><p style="text-align: left;"> uvicorn[standard]</p><p style="text-align: left;"> requests</p><p style="text-align: left;"> python-dotenv</p><p style="text-align: left;"> pydantic</p><p style="text-align: left;"> python-multipart</p><p style="text-align: left;"> # --- Celery and Redis ---</p><p style="text-align: left;"> celery[redis]</p><p style="text-align: left;"> redis[hiredis]</p><p style="text-align: left;"> # --- Database Dependencies ---</p><p style="text-align: left;"> sqlalchemy[asyncio]</p><p style="text-align: left;"> psycopg2-binary</p><p style="text-align: left;"> alembic</p><p style="text-align: left;"> asyncpg</p><p style="text-align: left;">+# --- Add Authentication Dependencies ---</p><p style="text-align: left;">+fastapi-users[sqlalchemy] </p><p style="text-align: left;">+# Note: [sqlalchemy] automatically includes sqlalchemy itself if not already present</p><p style="text-align: left;">+python-jose[cryptography] # For JWT handling</p><p style="text-align: left;">+passlib[bcrypt]          # For password hashing</p><p style="text-align: left;">+# --- End Add ---</p><p style="text-align: left;"> # Add later: pypdf2, Pillow, pydub, langdetect</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Diff</p><p style="text-align: left;">Install the new dependencies: pip install -r requirements.txt</p><p style="text-align: left;">(2) Update Configuration (backend/.env and backend/app/config.py)</p><p style="text-align: left;"></p><p style="text-align: left;">Add a JWT_SECRET_KEY to your .env file. Generate a strong, random secret key! You can use openssl rand -hex 32 in your terminal to generate one.</p><p style="text-align: left;"></p><p style="text-align: left;">HUGGINGFACE_API_TOKEN=&#34;hf_YOUR_ACTUAL_HUGGINGFACE_TOKEN&#34;</p><p style="text-align: left;"> DATABASE_URL=&#34;postgresql+asyncpg://postgres:mysecretpassword@localhost:5432/neuralblitz_db&#34;</p><p style="text-align: left;">+# --- Generate a strong secret key for JWT! ---</p><p style="text-align: left;">+JWT_SECRET_KEY=&#34;YOUR_VERY_STRONG_RANDOM_32_BYTE_HEX_SECRET_KEY&#34;</p><p style="text-align: left;"> REDIS_URL=&#34;redis://localhost:6379/0&#34;</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Diff</p><p style="text-align: left;">Replace YOUR_VERY_STRONG_RANDOM_32_BYTE_HEX_SECRET_KEY with your generated key.</p><p style="text-align: left;"></p><p style="text-align: left;">Update backend/app/config.py to include JWT settings:</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/config.py</p><p style="text-align: left;"> # ... (other imports) ...</p><p style="text-align: left;">+from typing import List </p><p style="text-align: left;"></p><p style="text-align: left;"> class Settings(BaseSettings):</p><p style="text-align: left;">     # ... (HF_API_TOKEN, HF_API_BASE_URL, Models, DB URL) ...</p><p style="text-align: left;">     DATABASE_URL: str = os.getenv(&#34;DATABASE_URL&#34;, &#34;sqlite+aiosqlite:///./default_dev.db&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">     CELERY_BROKER_URL: str = os.getenv(&#34;REDIS_URL&#34;, &#34;redis://localhost:6379/0&#34;)</p><p style="text-align: left;">     CELERY_RESULT_BACKEND: str = os.getenv(&#34;REDIS_URL&#34;, &#34;redis://localhost:6379/0&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">+    # --- JWT Authentication Settings ---</p><p style="text-align: left;">+    JWT_SECRET_KEY: str = os.getenv(&#34;JWT_SECRET_KEY&#34;, &#34;super_weak_default_key_change_me&#34;) # Use a strong default or raise error</p><p style="text-align: left;">+    JWT_ALGORITHM: str = &#34;HS256&#34;</p><p style="text-align: left;">+    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 # 1 day expiration</p><p style="text-align: left;">+</p><p style="text-align: left;">+    # --- fastapi-users specific ---</p><p style="text-align: left;">+    # Set to True if you want email verification, requires email setup</p><p style="text-align: left;">+    USERS_EMAIL_VERIFICATION_ENABLED: bool = False </p><p style="text-align: left;">+    # Add other fastapi-users settings as needed (e.g., reset password URL)</p><p style="text-align: left;">+</p><p style="text-align: left;">     # ... (validators) ...</p><p style="text-align: left;">     @validator(&#39;JWT_SECRET_KEY&#39;)</p><p style="text-align: left;">     def check_jwt_secret(cls, v):</p><p style="text-align: left;">         if v == &#34;super_weak_default_key_change_me&#34;:</p><p style="text-align: left;">              print(&#34;\n**************************************************************&#34;)</p><p style="text-align: left;">              print(&#34;WARNING: JWT_SECRET_KEY is weak or default. SET A STRONG KEY IN .env!&#34;)</p><p style="text-align: left;">              print(&#34;**************************************************************\n&#34;)</p><p style="text-align: left;">         elif len(v) &#60; 32: # Basic length check</p><p style="text-align: left;">             print(&#34;\n**************************************************************&#34;)</p><p style="text-align: left;">             print(f&#34;WARNING: JWT_SECRET_KEY seems short ({len(v)} chars). Recommended: &#62;= 32 random hex chars.&#34;)</p><p style="text-align: left;">             print(&#34;**************************************************************\n&#34;)</p><p style="text-align: left;">         return v</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"> settings = Settings()</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(3) Update DB Model (backend/app/db_models.py)</p><p style="text-align: left;"></p><p style="text-align: left;">Modify the User model to inherit from fastapi_users.db.SQLAlchemyBaseUserTableUUID (or SQLAlchemyBaseUserTable if using integer IDs) and add required fields. Let&#39;s stick with Integer IDs for now to match TaskRecord.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/db_models.py</p><p style="text-align: left;"># import uuid # Not needed if using Integer ID</p><p style="text-align: left;">from sqlalchemy import Column, String, DateTime, Text, ForeignKey, Integer, JSON, Float, Boolean</p><p style="text-align: left;"># from sqlalchemy.dialects.postgresql import UUID</p><p style="text-align: left;">from sqlalchemy.orm import relationship</p><p style="text-align: left;">from sqlalchemy.sql import func</p><p style="text-align: left;">+from fastapi_users.db import SQLAlchemyBaseUserTable # Use Integer ID version</p><p style="text-align: left;"> from .database import Base</p><p style="text-align: left;"></p><p style="text-align: left;">-class User(Base): # Old definition</p><p style="text-align: left;">-    __tablename__ = &#34;users&#34;</p><p style="text-align: left;">-    id = Column(Integer, primary_key=True, index=True)</p><p style="text-align: left;">-    email = Column(String, unique=True, index=True, nullable=False)</p><p style="text-align: left;">-    hashed_password = Column(String, nullable=False)</p><p style="text-align: left;">-    is_active = Column(Boolean, default=True)</p><p style="text-align: left;">-    is_superuser = Column(Boolean, default=False) </p><p style="text-align: left;">-    tasks = relationship(&#34;TaskRecord&#34;, back_populates=&#34;owner&#34;, lazy=&#34;selectin&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">+class User(SQLAlchemyBaseUserTable[int], Base): # Inherit from fastapi-users base</p><p style="text-align: left;">+    # Inherited fields: id (int PK), email, hashed_password, is_active, is_superuser, is_verified</p><p style="text-align: left;">+    # You can add custom fields here if needed, e.g.:</p><p style="text-align: left;">+    # full_name = Column(String, nullable=True)</p><p style="text-align: left;">+    </p><p style="text-align: left;">+    # Define relationships explicitly if needed (fastapi-users might not define back_populates)</p><p style="text-align: left;">+    tasks = relationship(&#34;TaskRecord&#34;, back_populates=&#34;owner&#34;, lazy=&#34;selectin&#34;, cascade=&#34;all, delete-orphan&#34;)</p><p style="text-align: left;">+    saved_results = relationship(&#34;SavedResult&#34;, back_populates=&#34;user&#34;, lazy=&#34;selectin&#34;, cascade=&#34;all, delete-orphan&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"> class TaskRecord(Base):</p><p style="text-align: left;">     __tablename__ = &#34;task_records&#34;</p><p style="text-align: left;">-    id = Column(String, primary_key=True, index=True) </p><p style="text-align: left;">+    # Change primary key to Integer for simplicity, or keep as String if preferred</p><p style="text-align: left;">+    id = Column(Integer, primary_key=True, index=True, autoincrement=True) </p><p style="text-align: left;">     celery_task_id = Column(String, unique=True, index=True, nullable=False)</p><p style="text-align: left;">     user_id = Column(Integer, ForeignKey(&#34;users.id&#34;), nullable=True, index=True) # Matches User.id type</p><p style="text-align: left;">     task_type = Column(String, index=True, nullable=False)</p><p style="text-align: left;">     status = Column(String, default=&#34;PENDING&#34;, index=True, nullable=False)</p><p style="text-align: left;">     created_at = Column(DateTime(timezone=True), server_default=func.now())</p><p style="text-align: left;">     updated_at = Column(DateTime(timezone=True), onupdate=func.now())</p><p style="text-align: left;">     input_payload = Column(JSON, nullable=True)</p><p style="text-align: left;">     result = Column(JSON, nullable=True)</p><p style="text-align: left;">     error_message = Column(Text, nullable=True)</p><p style="text-align: left;"></p><p style="text-align: left;">-    owner = relationship(&#34;User&#34;, back_populates=&#34;tasks&#34;) </p><p style="text-align: left;">+    owner = relationship(&#34;User&#34;, back_populates=&#34;tasks&#34;) # Relationship to User</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;"> class SavedResult(Base):</p><p style="text-align: left;">     __tablename__ = &#34;saved_results&#34;</p><p style="text-align: left;">     id = Column(Integer, primary_key=True, index=True)</p><p style="text-align: left;">     user_id = Column(Integer, ForeignKey(&#34;users.id&#34;), nullable=False, index=True) # Matches User.id type</p><p style="text-align: left;">-    task_id = Column(String, ForeignKey(&#34;task_records.id&#34;), unique=True, nullable=False, index=True) # Matches TaskRecord.id type -&#62; Change to Integer</p><p style="text-align: left;">+    task_id = Column(Integer, ForeignKey(&#34;task_records.id&#34;), unique=True, nullable=False, index=True) </p><p style="text-align: left;">     saved_at = Column(DateTime(timezone=True), server_default=func.now())</p><p style="text-align: left;">     custom_name = Column(String, nullable=True)</p><p style="text-align: left;"></p><p style="text-align: left;">-    task = relationship(&#34;TaskRecord&#34;, back_populates=&#34;saved_result&#34;)</p><p style="text-align: left;">-    user = relationship(&#34;User&#34;) # Link back to user</p><p style="text-align: left;">+    task = relationship(&#34;TaskRecord&#34;, back_populates=&#34;saved_result&#34;)</p><p style="text-align: left;">+    user = relationship(&#34;User&#34;, back_populates=&#34;saved_results&#34;) # Link back to user</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">Important: Since we modified the User table structure and potentially TaskRecord/SavedResult primary/foreign keys, we need a new Alembic migration.</p><p style="text-align: left;">Generate Migration: alembic revision --autogenerate -m &#34;Add fastapi-users fields and sync FKs&#34;</p><p style="text-align: left;">Inspect: Carefully check the generated migration script in alembic/versions/. Ensure it correctly adds columns to users and modifies FKs if needed.</p><p style="text-align: left;">Apply Migration: alembic upgrade head</p><p style="text-align: left;">(4) Implement Authentication Backend (backend/app/auth.py - NEW FILE)</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/auth.py</p><p style="text-align: left;">import uuid</p><p style="text-align: left;">from typing import Optional</p><p style="text-align: left;"></p><p style="text-align: left;">from fastapi import Depends, Request</p><p style="text-align: left;">from fastapi_users import BaseUserManager, IntegerIDMixin, schemas, models, exceptions # Use IntegerIDMixin</p><p style="text-align: left;">from fastapi_users.authentication import (</p><p style="text-align: left;">    AuthenticationBackend, BearerTransport, JWTStrategy</p><p style="text-align: left;">)</p><p style="text-align: left;">from fastapi_users.db import SQLAlchemyUserDatabase</p><p style="text-align: left;"></p><p style="text-align: left;">from .db_models import User # Import the enhanced DB User model</p><p style="text-align: left;">from .database import get_db # Need the async session dependency</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession # Import AsyncSession for type hint</p><p style="text-align: left;"></p><p style="text-align: left;"># --- User Schemas (Pydantic models for API input/output) ---</p><p style="text-align: left;">class UserRead(schemas.BaseUser[int]): # Use int for ID</p><p style="text-align: left;">    # Add any custom fields from your User model here if you want them readable</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;">class UserCreate(schemas.BaseUserCreate):</p><p style="text-align: left;">    # If you add custom required fields to User, add them here</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;">class UserUpdate(schemas.BaseUserUpdate):</p><p style="text-align: left;">     # If you add custom updateable fields, add them here</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Database Adapter ---</p><p style="text-align: left;">async def get_user_db(session: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    yield SQLAlchemyUserDatabase(session, User) # Pass DB model here</p><p style="text-align: left;"></p><p style="text-align: left;"># --- User Manager ---</p><p style="text-align: left;"># Handles hashing passwords, validation etc. Needs SECRET from settings.</p><p style="text-align: left;">class UserManager(IntegerIDMixin, BaseUserManager[User, int]): # Specify User model and int ID type</p><p style="text-align: left;">    reset_password_token_secret = settings.JWT_SECRET_KEY</p><p style="text-align: left;">    verification_token_secret = settings.JWT_SECRET_KEY # Use same secret or different one</p><p style="text-align: left;"></p><p style="text-align: left;">    async def on_after_register(self, user: User, request: Optional[Request] = None):</p><p style="text-align: left;">        print(f&#34;User {user.id} ({user.email}) has registered.&#34;)</p><p style="text-align: left;">        # TODO: Send verification email if settings.USERS_EMAIL_VERIFICATION_ENABLED is True</p><p style="text-align: left;"></p><p style="text-align: left;">    async def on_after_forgot_password(self, user: User, token: str, request: Optional[Request] = None):</p><p style="text-align: left;">        print(f&#34;User {user.id} has requested password reset. Token: {token}&#34;)</p><p style="text-align: left;">        # TODO: Send password reset email</p><p style="text-align: left;"></p><p style="text-align: left;">    # Override create method if you need custom validation before saving</p><p style="text-align: left;">    async def create(</p><p style="text-align: left;">        self,</p><p style="text-align: left;">        user_create: schemas.UC, # UC is UserCreate schema</p><p style="text-align: left;">        safe: bool = False,</p><p style="text-align: left;">        request: Optional[Request] = None,</p><p style="text-align: left;">    ) -&#62; models.UP: # UP is the User DB Model</p><p style="text-align: left;">        # Example custom validation: Prohibit certain email domains</p><p style="text-align: left;">        # if &#34;forbidden.com&#34; in user_create.email:</p><p style="text-align: left;">        #     raise exceptions.UserAlreadyExists() # Or a custom validation exception</p><p style="text-align: left;">        </p><p style="text-align: left;">        # Call parent create method</p><p style="text-align: left;">        created_user = await super().create(user_create, safe, request)</p><p style="text-align: left;">        print(f&#34;User created in DB: {created_user.email}&#34;)</p><p style="text-align: left;">        return created_user</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">async def get_user_manager(user_db: SQLAlchemyUserDatabase = Depends(get_user_db)):</p><p style="text-align: left;">    yield UserManager(user_db)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Authentication Backend Setup ---</p><p style="text-align: left;"></p><p style="text-align: left;">bearer_transport = BearerTransport(tokenUrl=&#34;auth/jwt/login&#34;) # Endpoint provided by fastapi-users router</p><p style="text-align: left;"></p><p style="text-align: left;">def get_jwt_strategy() -&#62; JWTStrategy:</p><p style="text-align: left;">    return JWTStrategy(secret=settings.JWT_SECRET_KEY, lifetime_seconds=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60)</p><p style="text-align: left;"></p><p style="text-align: left;"># The main authentication backend instance</p><p style="text-align: left;">auth_backend = AuthenticationBackend(</p><p style="text-align: left;">    name=&#34;jwt&#34;,</p><p style="text-align: left;">    transport=bearer_transport,</p><p style="text-align: left;">    get_strategy=get_jwt_strategy,</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Dependency for getting current active user ---</p><p style="text-align: left;"># fastapi_users provides this, combining backend and user manager</p><p style="text-align: left;">fastapi_users = fastapi_users.FastAPIUsers[User, int]( # Specify User and ID type</p><p style="text-align: left;">    get_user_manager,</p><p style="text-align: left;">    [auth_backend],</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># Dependency callable to protect routes</p><p style="text-align: left;"># Will raise HTTPException if user is not authenticated or inactive</p><p style="text-align: left;">current_active_user = fastapi_users.current_user(active=True) </p><p style="text-align: left;"># Optional: Dependency for superusers</p><p style="text-align: left;"># current_active_superuser = fastapi_users.current_user(active=True, superuser=True)</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(5) Integrate Auth Routers (backend/app/main.py)</p><p style="text-align: left;"></p><p style="text-align: left;">Include the pre-built routers from fastapi-users for common auth operations.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/main.py</p><p style="text-align: left;">from fastapi import FastAPI, Depends # Add Depends</p><p style="text-align: left;">from fastapi.middleware.cors import CORSMiddleware</p><p style="text-align: left;">from . import api</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .database import engine, Base</p><p style="text-align: left;">+from .auth import auth_backend, fastapi_users, current_active_user # Import auth components</p><p style="text-align: left;">+from .auth import UserRead, UserCreate # Import auth schemas</p><p style="text-align: left;"></p><p style="text-align: left;">app = FastAPI(</p><p style="text-align: left;">    title=&#34;NeuralBlitz Multi-Tool AI - v0.3 Auth Integrated&#34;,</p><p style="text-align: left;">    description=&#34;Backend API with Celery tasks, DB persistence, and JWT Auth.&#34;,</p><p style="text-align: left;">    version=&#34;0.3.0&#34;</p><p style="text-align: left;">)</p><p style="text-align: left;"></p><p style="text-align: left;"># ... (CORS Middleware setup remains the same) ...</p><p style="text-align: left;"></p><p style="text-align: left;"># Include the main API router</p><p style="text-align: left;">app.include_router(api.router)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Include fastapi-users authentication routers ---</p><p style="text-align: left;"># Provides /login, /logout</p><p style="text-align: left;">app.include_router(</p><p style="text-align: left;">    fastapi_users.get_auth_router(auth_backend),</p><p style="text-align: left;">    prefix=&#34;/auth/jwt&#34;,</p><p style="text-align: left;">    tags=[&#34;Auth&#34;]</p><p style="text-align: left;">)</p><p style="text-align: left;"># Provides /register</p><p style="text-align: left;">app.include_router(</p><p style="text-align: left;">    fastapi_users.get_register_router(UserRead, UserCreate),</p><p style="text-align: left;">    prefix=&#34;/auth&#34;,</p><p style="text-align: left;">    tags=[&#34;Auth&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"># Provides /request-password-reset, /reset-password</p><p style="text-align: left;"># Requires email sending setup to be functional</p><p style="text-align: left;">app.include_router(</p><p style="text-align: left;">    fastapi_users.get_reset_password_router(),</p><p style="text-align: left;">    prefix=&#34;/auth&#34;,</p><p style="text-align: left;">    tags=[&#34;Auth&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"># Provides /request-verify-token, /verify</p><p style="text-align: left;"># Requires email sending setup and USERS_EMAIL_VERIFICATION_ENABLED=True</p><p style="text-align: left;"># app.include_router(</p><p style="text-align: left;">#     fastapi_users.get_verify_router(UserRead),</p><p style="text-align: left;">#     prefix=&#34;/auth&#34;,</p><p style="text-align: left;">#     tags=[&#34;Auth&#34;],</p><p style="text-align: left;"># )</p><p style="text-align: left;"># Provides routes to manage users (/users/me, /users/{id}) - careful enabling in production</p><p style="text-align: left;">app.include_router(</p><p style="text-align: left;">    fastapi_users.get_users_router(UserRead, UserUpdate),</p><p style="text-align: left;">    prefix=&#34;/users&#34;,</p><p style="text-align: left;">    tags=[&#34;Users&#34;],</p><p style="text-align: left;">)</p><p style="text-align: left;"># --- End fastapi-users routers ---</p><p style="text-align: left;"></p><p style="text-align: left;"></p><p style="text-align: left;">@app.get(&#34;/&#34;)</p><p style="text-align: left;">async def read_root():</p><p style="text-align: left;">    # ... (root endpoint remains same) ...</p><p style="text-align: left;">    token_status = &#34;SET&#34; if settings.HF_API_TOKEN and settings.HF_API_TOKEN != &#34;YOUR_TOKEN_HERE&#34; else &#34;MISSING/INVALID&#34;</p><p style="text-align: left;">    db_status = &#34;Configured&#34; if settings.DATABASE_URL else &#34;Missing/Invalid URL&#34;</p><p style="text-align: left;">    auth_status = &#34;Configured&#34; if settings.JWT_SECRET_KEY != &#34;super_weak_default_key_change_me&#34; else &#34;WEAK/DEFAULT SECRET!&#34;</p><p style="text-align: left;">    return {</p><p style="text-align: left;">        &#34;message&#34;: &#34;Welcome to the NeuralBlitz AI Backend!&#34;,</p><p style="text-align: left;">        &#34;status&#34;: &#34;Operational&#34;,</p><p style="text-align: left;">        &#34;version&#34;: &#34;0.3.0&#34;,</p><p style="text-align: left;">        &#34;huggingface_token_status&#34;: token_status,</p><p style="text-align: left;">        &#34;database_status&#34;: db_status,</p><p style="text-align: left;">        &#34;auth_status&#34;: auth_status</p><p style="text-align: left;">    }</p><p style="text-align: left;"></p><p style="text-align: left;"># Example of a protected route</p><p style="text-align: left;">@app.get(&#34;/authenticated-route&#34;, tags=[&#34;Test&#34;])</p><p style="text-align: left;">async def authenticated_route(user: User = Depends(current_active_user)):</p><p style="text-align: left;">    &#34;&#34;&#34;An example route that requires authentication.&#34;&#34;&#34;</p><p style="text-align: left;">    return {&#34;message&#34;: f&#34;Hello {user.email}! You are authenticated.&#34;}</p><p style="text-align: left;"></p><p style="text-align: left;"># TODO: Add DB startup event if needed</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(6) Protect API Endpoints (backend/app/api.py)</p><p style="text-align: left;"></p><p style="text-align: left;">Add the user: User = Depends(current_active_user) dependency to the endpoints you want to protect. Also, modify the service calls to pass the user.id.</p><p style="text-align: left;"></p><p style="text-align: left;"># backend/app/api.py</p><p style="text-align: left;">from fastapi import APIRouter, HTTPException, Depends, UploadFile, File</p><p style="text-align: left;">from sqlalchemy.ext.asyncio import AsyncSession</p><p style="text-align: left;">from typing import List, Optional</p><p style="text-align: left;">from . import models</p><p style="text-align: left;">from . import services</p><p style="text-align: left;">from .config import settings</p><p style="text-align: left;">from .database import get_db</p><p style="text-align: left;">+from .auth import current_active_user # Import the dependency</p><p style="text-align: left;">+from .db_models import User as DBUser # Import the DB User model</p><p style="text-align: left;"></p><p style="text-align: left;">router = APIRouter()</p><p style="text-align: left;"></p><p style="text-align: left;"># ... (_parse_db_task_result helper remains the same) ...</p><p style="text-align: left;"></p><p style="text-align: left;"># --- API Endpoints (Updated with Auth) ---</p><p style="text-align: left;"></p><p style="text-align: left;"># Example: Sentiment remains public for now, but could be protected</p><p style="text-align: left;">@router.post(&#34;/api/sentiment&#34;, ...)</p><p style="text-align: left;">async def analyze_sentiment(data: models.TextInput, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">    # ... (implementation mostly same, could optionally log anonymous task) ...</p><p style="text-align: left;">    pass</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Protected Background Task Endpoints ---</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/summarize&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def summarize_text(</p><p style="text-align: left;">    data: models.SummarizationRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db),</p><p style="text-align: left;">    user: DBUser = Depends(current_active_user) # Require authenticated user</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for text summarization via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_summarization(db, data.text, data.min_length, data.max_length, user.id) # Pass user.id</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/translate&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def translate_text(</p><p style="text-align: left;">    data: models.TranslationRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for translation via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.target_lang or len(data.target_lang) &#60; 2: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_translation(db, data.text, data.source_lang, data.target_lang, user.id) # Pass user.id</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-image&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_image(</p><p style="text-align: left;">    data: models.ImageGenRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for image generation via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_image_generation(db, data.prompt, data.negative_prompt, user.id) # Pass user.id</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/qa-document&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def qa_document(</p><p style="text-align: left;">    data: models.DocQARequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for Document QA via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.context or not data.question: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_doc_qa(db, data.context, data.question, user.id) # Pass user.id</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/transcribe&#34;, response_model=models.TaskResponse, responses={400: {&#34;model&#34;: models.ErrorResponse}, 500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def transcribe_audio(</p><p style="text-align: left;">    file: UploadFile = File(...), </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for audio transcription via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not file.content_type.startswith(&#34;audio/&#34;): raise HTTPException(status_code=400, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        audio_bytes = await file.read()</p><p style="text-align: left;">        if not audio_bytes: raise HTTPException(status_code=400, detail=&#34;...&#34;)</p><p style="text-align: left;">        db_task = await services.start_transcription(db, audio_bytes, user.id) # Pass user.id</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;">    finally: await file.close()</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/text-to-speech&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def text_to_speech(</p><p style="text-align: left;">    data: models.TextToSpeechRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for TTS via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_tts(db, data.text, user.id) # Pass user.id</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/generate-code&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def generate_code(</p><p style="text-align: left;">    data: models.CodeGenRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for code generation via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.prompt or not data.language: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_code_generation(db, data.prompt, data.language, user.id) # Pass user.id</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/classify-zero-shot&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def classify_zero_shot(</p><p style="text-align: left;">    data: models.ZeroShotRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for zero-shot classification via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text or not data.candidate_labels: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">         db_task = await services.start_zero_shot(db, data.text, data.candidate_labels, user.id) # Pass user.id</p><p style="text-align: left;">         return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;">@router.post(&#34;/api/extract-entities&#34;, response_model=models.TaskResponse, responses={500: {&#34;model&#34;: models.ErrorResponse}})</p><p style="text-align: left;">async def extract_entities(</p><p style="text-align: left;">    data: models.NerRequest, </p><p style="text-align: left;">    db: AsyncSession = Depends(get_db), </p><p style="text-align: left;">    user: DBUser = Depends(current_active_user)</p><p style="text-align: left;">):</p><p style="text-align: left;">    &#34;&#34;&#34;Starts background task for NER via Celery &#38; saves record for user.&#34;&#34;&#34;</p><p style="text-align: left;">    if not data.text: raise HTTPException(status_code=422, detail=&#34;...&#34;)</p><p style="text-align: left;">    try:</p><p style="text-align: left;">        db_task = await services.start_ner(db, data.text, user.id) # Pass user.id</p><p style="text-align: left;">        return models.TaskResponse(task_id=db_task.id, status=&#34;SUBMITTED&#34;)</p><p style="text-align: left;">    except HTTPException as e: raise e</p><p style="text-align: left;">    except Exception as e: raise HTTPException(status_code=500, detail=f&#34;Failed: {e}&#34;)</p><p style="text-align: left;"></p><p style="text-align: left;"># --- Central Task Status Endpoint (Remains public or protect as needed) ---</p><p style="text-align: left;">@router.get(&#34;/api/task-status/{task_id}&#34;, ...)</p><p style="text-align: left;">async def get_task_status_endpoint(task_id: str, db: AsyncSession = Depends(get_db)):</p><p style="text-align: left;">     # ... (implementation remains same, reads from DB) ...</p><p style="text-align: left;">     # Consider adding logic to check if the task belongs to the requesting user if this needs protection</p><p style="text-align: left;">     pass</p><p style="text-align: left;"></p><p style="text-align: left;"># --- TODO: Add History &#38; Saving Endpoints (Now feasible with Auth) ---</p><p style="text-align: left;"># @router.get(&#34;/api/history&#34;, response_model=List[models.TaskStatusResponse])</p><p style="text-align: left;"># async def get_user_history(db: AsyncSession = Depends(get_db), user: DBUser = Depends(current_active_user)):</p><p style="text-align: left;">#     user_tasks = await crud.get_user_tasks(db, user.id) # Need to implement crud.get_user_tasks</p><p style="text-align: left;">#     # ... parse results and return ...</p><p style="text-align: left;"></p><p style="text-align: left;"># @router.post(&#34;/api/save/{task_id}&#34;, status_code=201)</p><p style="text-align: left;"># async def save_task_result(task_id: int, db: AsyncSession = Depends(get_db), user: DBUser = Depends(current_active_user)):</p><p style="text-align: left;">#      db_task = await crud.get_task_record(db, task_id)</p><p style="text-align: left;">#      if not db_task or db_task.user_id != user.id: raise HTTPException(404, &#34;Task not found or not owned&#34;)</p><p style="text-align: left;">#      if db_task.status != &#34;SUCCESS&#34;: raise HTTPException(400, &#34;Can only save successful tasks&#34;)</p><p style="text-align: left;">#      # await crud.create_saved_result(db, user_id=user.id, task_id=task_id) # Need to implement crud.create_saved_result</p><p style="text-align: left;">#      return {&#34;message&#34;: &#34;Result saved&#34;}</p><p style="text-align: left;">content_copy</p><p style="text-align: left;">download</p><p style="text-align: left;">Use code with caution.</p><p style="text-align: left;">Python</p><p style="text-align: left;">(7) Frontend Authentication Implementation (Conceptual - React)</p><p style="text-align: left;"></p><p style="text-align: left;">Create Context: Set up a React Context (e.g., AuthContext) to store the user object and JWT token. Provide functions for login, logout, register.</p><p style="text-align: left;">Update apiService.js:</p><p style="text-align: left;">Add functions to call backend /auth/jwt/login and /auth/register endpoints.</p><p style="text-align: left;">Store the received JWT token (e.g., in localStorage).</p><p style="text-align: left;">Implement the Axios interceptor (or add header logic to fetch) to read the token from storage and add the Authorization: Bearer &#60;token&#62; header to relevant API calls.</p><p style="text-align: left;">Add a logout function that removes the token from storage.</p><p style="text-align: left;">Create Login/Register Components: Build forms that use the apiService functions to log in or register users, updating the AuthContext upon success.</p><p style="text-align: left;">Implement Protected Routes: In App.js, wrap routes that require authentication with a component that checks the AuthContext state. If not logged in, redirect to the login page.</p><p style="text-align: left;">Update NavBar: Show Login/Register links or Logout/User Info based on AuthContext state.</p><p style="text-align: left;">Pass User Info (If Needed): While most backend endpoints now derive the user from the token, if frontend components need user info (like email), get it from the AuthContext.</p><p style="text-align: left;">(8) Run &#38; Test</p><p style="text-align: left;"></p><p style="text-align: left;">Ensure PostgreSQL and Redis are running.</p><p style="text-align: left;">Run Alembic migrations: alembic upgrade head</p><p style="text-align: left;">Start Backend: uvicorn app.main:app --reload --port 8000</p><p style="text-align: left;">Start Celery Worker: celery -A app.celery_app worker --loglevel=info -P solo</p><p style="text-align: left;">Start Frontend: npm start</p><p style="text-align: left;">Test:</p><p style="text-align: left;">Use the /docs endpoint on the backend (http://localhost:8000/docs) to test registration and login via the /auth/register and /auth/jwt/login endpoints.</p><p style="text-align: left;">Copy the access_token received from login.</p><p style="text-align: left;">Use the /docs endpoint again (or frontend once updated) to try accessing protected endpoints (like /api/summarize). Use the &#34;Authorize&#34; button in Swagger UI to add Bearer &#60;your_token&#62;. Verify it works when authorized and fails (401 Unauthorized) when not.</p><p style="text-align: left;">Test the frontend login/registration flow once implemented.</p><p style="text-align: left;">Summary of Progress:</p><p style="text-align: left;"></p><p style="text-align: left;">fastapi-users integrated for robust user management and authentication.</p><p style="text-align: left;">JWT strategy configured for token-based auth.</p><p style="text-align: left;">Database model for User updated.</p><p style="text-align: left;">Alembic migrations created and applied.</p><p style="text-align: left;">Authentication backend, user manager, and dependencies set up.</p><p style="text-align: left;">Standard auth API routes (/auth/jwt/login, /auth/register, etc.) added to the FastAPI app.</p><p style="text-align: left;">Core API endpoints (/api/...) are now protected, requiring authentication, and linked to user_id in the database via updated service calls.</p><p style="text-align: left;">Conceptual plan for frontend integration outlined.</p><p style="text-align: left;">The backend now has a solid authentication system. The next immediate step would be to implement the frontend components and context to handle login, registration, token management, and accessing protected routes. After that, implementing the database logic for saving/retrieving history would be logical.</p><p style="text-align: left;"></p></article></section></body></html>